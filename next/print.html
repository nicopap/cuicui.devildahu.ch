<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cuicui Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="The user guide and reference of the cuicui framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="choosing_a_cuicui_crate.html"><strong aria-hidden="true">1.</strong> Choosing a cuicui crate</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">2.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/simple_menu/index.html"><strong aria-hidden="true">2.1.</strong> Using the DSL directly</a></li><li class="chapter-item expanded "><a href="../examples/chirp_menu/index.html"><strong aria-hidden="true">2.2.</strong> Using a chirp file</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/chirpunk/index.html"><strong aria-hidden="true">3.1.</strong> chirpunk</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="../dsl/index.html"><strong aria-hidden="true">4.</strong> cuicui_dsl</a></li><li class="chapter-item expanded "><a href="../chirp/index.html"><strong aria-hidden="true">5.</strong> cuicui_chirp</a></li><li class="chapter-item expanded "><a href="../layout/index.html"><strong aria-hidden="true">6.</strong> cuicui_layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../layout/debug.html"><strong aria-hidden="true">6.1.</strong> Layout debug overlay</a></li><li class="chapter-item expanded "><a href="../layout/content_sized.html"><strong aria-hidden="true">6.2.</strong> Content-sized leaf nodes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cuicui Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cuicui-framework"><a class="header" href="#the-cuicui-framework">The <code>cuicui</code> framework</a></h1>
<p><code>cuicui</code> is a collection of crates to work with bevy scenes and making UIs in bevy.</p>
<p>This book contains a user-focused guide on how to use the <code>cuicui</code> crates and
more reference-level documentation on what the capabilities of each crate are.</p>
<h2 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic versioning</a></h2>
<p>All crates in the <code>cuicui</code> framework follow a synchronous release model, similar
to bevy's. However, the release cadence is independent from bevy's.</p>
<h4 id="version-matrix"><a class="header" href="#version-matrix">Version matrix</a></h4>
<div class="table-wrapper"><table><thead><tr><th>bevy</th><th>latest supporting version</th></tr></thead><tbody>
<tr><td>0.11</td><td>0.9.0</td></tr>
<tr><td>0.10</td><td>0.3.0</td></tr>
</tbody></table>
</div>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<p><code>cuicui</code> is a playground for experiments, so use at your own risk,
it is likely that a lot of things are going to break each release.</p>
<h2 id="cuicui-crates"><a class="header" href="#cuicui-crates"><code>cuicui</code> crates</a></h2>
<p>The crates included in <code>cuicui</code> are:</p>
<ul>
<li><a href="dsl"><code>cuicui_dsl</code></a>: The <code>dsl!</code> macro and <code>DslBundle</code>.</li>
<li><a href="chirp"><code>cuicui_chirp</code></a>: A parser for files that follow the <code>dsl!</code>
syntax. It creates a scene identical to what the same text passed to the
<code>dsl!</code> macro would produce.
<br />
It also includes a bevy plugin to load <code>.chirp</code> files defined in this format.</li>
<li><a href="layout"><code>cuicui_layout</code></a>: The base algorithm and components, does not make any assumption
about how it is used, beside the requirement that layout nodes be bevy <code>Entitiy</code> and
uses <code>bevy_hierarchy</code>.</li>
<li><a href="choosing_a_cuicui_crate.html"><code>cuicui_layout_bevy_ui</code></a>: Integration with <code>bevy_ui</code>, including extension to <code>UiDsl</code>
for <code>UiImage</code>, <code>Text</code>, background images and background colors.</li>
<li><a href="choosing_a_cuicui_crate.html"><code>cuicui_layout_bevy_sprite</code></a>: <code>bevy_sprite</code> integration, supports
<code>Mesh2dHandle</code>, <code>Sprite</code> and <code>Text2d</code>. This isn't as good as the <code>bevy_ui</code>-based integration
when it comes to content-driven sizes, but otherwise should work very much like the <code>bevy_ui</code>
integration.</li>
</ul>
<h2 id="supporting-development"><a class="header" href="#supporting-development">Supporting development</a></h2>
<p>This crate is a single person effort. I don't get paid for it, and is generally
unsustainable. Please consider donating to make <code>cuicui</code> sustainable.</p>
<p><a href="https://github.com/sponsors/nicopap">https://github.com/sponsors/nicopap</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-which-crates-to-use"><a class="header" href="#choosing-which-crates-to-use">Choosing which crates to use</a></h1>
<p>Confused by all the cuicui crates? Understandable, there is a lot of them, with
very long names too!</p>
<p>Let's split the task in two. Ask yourself two questions:</p>
<ul>
<li>What do I want to layout?</li>
<li>How do I want to spawn UI scene?</li>
</ul>
<p>The following sections tell you which crate to use depending on the answer.</p>
<h2 id="layouting"><a class="header" href="#layouting">Layouting</a></h2>
<p>All you want is some sort of layouting algorithm that you can keep in your head?
Then use <a href="layout"><code>cuicui_layout</code></a> without any other crates.</p>
<ul>
<li>Interested in a ready-made UI library on top of <code>bevy_ui</code>?
Then, use <a href="https://docs.rs/cuicui_layout_bevy_ui/0.9.0/cuicui_layout_bevy_ui/index.html"><code>cuicui_layout_bevy_ui</code></a>.</li>
<li>Want more flexibility? Using <a href="layout"><code>cuicui_layout</code></a> on top of <code>bevy_sprite</code> will let you
integrate your UI with a lot of 3rd party crates that only work with sprites.
Then use <a href="https://docs.rs/cuicui_layout_bevy_sprite/0.9.0/cuicui_layout_bevy_sprite/index.html"><code>cuicui_layout_bevy_sprite</code></a>.</li>
<li>Using <code>cuicui_layout</code> with your own custom rendering system? Again, bare <code>cuicui_layout</code>
is what you want.</li>
</ul>
<h2 id="scene-syntax"><a class="header" href="#scene-syntax">Scene syntax</a></h2>
<p>Then you need to decide how to spawn full scenes or UI layouts.</p>
<ul>
<li>Using the default bevy syntax, with nested <code>cmds.insert(…).with_children(…)</code>?
No need to add any crate for this :P</li>
<li>Just want something a bit less verbose that the default syntax? Something
very lightweight you can use in your rust code? Don't mind recompiling the
whole game for each UI touchups? Then use <a href="dsl"><code>cuicui_dsl</code></a>.</li>
<li>Want quick iteration times with hot reloading, an advanced scene file format
with templating, basically an actual scripting language? Ready to
sacrifice some compile time for this? Then use <a href="chirp"><code>cuicui_chirp</code></a>.</li>
</ul>
<p>The <a href="dsl/index.html#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp"><code>cuicui_dsl</code> page</a> has a comparison matrix with <a href="chirp"><code>cuicui_chirp</code></a> to give
you a more detailed idea.</p>
<p>Note that the <a href="https://docs.rs/cuicui_layout_bevy_ui/0.9.0/cuicui_layout_bevy_ui/index.html"><code>cuicui_layout_bevy_ui</code></a> and <a href="https://docs.rs/cuicui_layout_bevy_sprite/0.9.0/cuicui_layout_bevy_sprite/index.html"><code>cuicui_layout_bevy_sprite</code></a> crates
have the <code>chirp</code> feature enabled by default. If you don't care for it, then
disable it with <code>default-features = false</code>.</p>
<p>Furthermore, the integration crates depend on <code>cuicui_dsl</code> unconditionally, as
it is a very lightweight dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Now that we chose the cuicui crates we need, time to use them.</p>
<p>For illustration, we assume that we went with <code>cuicui_layout_bevy_ui</code>.</p>
<h2 id="adding-the-selected-crates"><a class="header" href="#adding-the-selected-crates">Adding the selected crates</a></h2>
<pre><code class="language-toml">[dependencies]
cuicui_layout_bevy_ui = &quot;0.9.0&quot;
cuicui_layout = &quot;0.9.0&quot;
cuicui_dsl = &quot;0.9.0&quot;
</code></pre>
<h2 id="using-the-dsl-macro"><a class="header" href="#using-the-dsl-macro">Using the <code>dsl!</code> macro</a></h2>
<p>That's it! You are now using <code>cuicui_layout</code>, congratulations!</p>
<p>Check the next two sections for actual rust code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-menu-using-cuicui_layout_bevy_ui"><a class="header" href="#define-a-menu-using-cuicui_layout_bevy_ui">Define a menu using <code>cuicui_layout_bevy_ui</code></a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>We added previously <code>cuicui_dsl</code>, <code>cuicui_layout</code>, and <code>cuicui_layout_bevy_ui</code>
to our <code>Cargo.toml</code>.</p>
<p>Now let's write some rust code.</p>
<p>We first import the relevant stuff:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;
use cuicui_dsl::dsl;
use cuicui_layout::{dsl_functions::*, LayoutRootCamera};
use cuicui_layout_bevy_ui::UiDsl as Dsl;</code></pre>
<p>Then, we initialize the bevy <code>app</code>, all standard bevy stuff.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins,
            // Notice that we add the plugin here.
            cuicui_layout_bevy_ui::Plugin,
            bevy_inspector_egui::quick::WorldInspectorPlugin::default(),
        ))
        .add_systems(Startup, setup)
        .run();
}</code></pre>
<p>Now we want to spawn the UI. Our UI will be a single menu with 7 buttons, each
with a different text. The buttons and menu all have a background, so we need
a <code>Res&lt;AssetServer&gt;</code>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut cmds: Commands, serv: Res&lt;AssetServer&gt;) {</code></pre>
<p><code>cuicui_layout</code> uses the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.LayoutRootCamera.html"><code>LayoutRootCamera</code></a> component to resize layouts based
on the viewport size. So let's spawn the camera with it:</p>
<pre><code class="language-rust no_run noplayground">    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));</code></pre>
<p>Now let's spawn the menu. The methods available on <a href="https://docs.rs/cuicui_layout_bevy_ui/0.9.0/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a> are listed on <code>docs.rs</code>.</p>
<p>Since <code>UiDsl</code> by default <code>Deref&lt;Target=LayoutDsl&gt;</code>, the methods on <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a> are
also available.</p>
<blockquote>
<p><strong>Note</strong>
This section is abbridged and might go in much more details in the future.</p>
</blockquote>
<p>We want:</p>
<ul>
<li>A column menu with the <code>board.png</code> background offset from the left edge of the
screen by 100 pixels.</li>
<li>This column contains a large <code>logo.png</code> and a smaller one, it also contains
7 buttons. We would want some margin between the edges of the screen and
the content of the coulmn, also between the button and the edge of the column.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let title_card = serv.load(&quot;logo.png&quot;);
    let bg = serv.load(&quot;background.jpg&quot;);
    let board = serv.load(&quot;board.png&quot;);
    let button = serv.load(&quot;button.png&quot;);

    dsl! {
        &amp;mut cmds.spawn_empty(),
        Root(layout(&quot;&gt;dSaS&quot;) screen_root main_margin(100.) image(&amp;bg)) {
            Menu(rules(px(310), pct(100)) main_margin(40.) image(&amp;board) column) {
                TitleCard(image(&amp;title_card) width(pct(100)))
                TitleCard2(ui(title_card) width(pct(50)))</code></pre>
<p>Again, you can see what each method (the functions within parenthesis) do by
checking the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a> and <a href="https://docs.rs/cuicui_layout_bevy_ui/0.9.0/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a> docs.</p>
<p>We only spawned the two title cards, now we spawn the buttons. To do that, we
will use a <code>code</code> block with a <code>for</code> loop</p>
<pre><code class="language-rust no_run noplayground">    let menu_buttons = [
        &quot;CONTINUE&quot;,
        &quot;NEW GAME&quot;,
        &quot;LOAD GAME&quot;,
        &quot;SETTINGS&quot;,
        &quot;ADDITIONAL CONTENT&quot;,
        &quot;CREDITS&quot;,
        &quot;QUIT GAME&quot;,
    ];
    let text = |value| Text::from_section(value, TextStyle { font_size: 30.0, ..default() });
    let title_card = serv.load(&quot;logo.png&quot;);
    let bg = serv.load(&quot;background.jpg&quot;);
    let board = serv.load(&quot;board.png&quot;);
    let button = serv.load(&quot;button.png&quot;);

    dsl! {
        &amp;mut cmds.spawn_empty(),
        Root(layout(&quot;&gt;dSaS&quot;) screen_root main_margin(100.) image(&amp;bg)) {
            Menu(rules(px(310), pct(100)) main_margin(40.) image(&amp;board) column) {
                TitleCard(image(&amp;title_card) width(pct(100)))
                TitleCard2(ui(title_card) width(pct(50)))
                code(let cmds) {
                    dsl!(cmds, Buttons(column height(child(2.)) width(pct(100))));
                    cmds.with_children(|cmds|{
                        for n in &amp;menu_buttons {
                            let name = format!(&quot;{n} button&quot;);
                            dsl!(
                                &amp;mut cmds.spawn_empty(),
                                Entity(ui(text(*n)) named(name) image(&amp;button) height(px(33)))
                            );
                        }
                    });
                }
            }
        }
    };</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-menu-using-a-chirp-file"><a class="header" href="#define-a-menu-using-a-chirp-file">Define a menu using a chirp file</a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<blockquote>
<p><strong>Note</strong>
This section is abbridged and might go in much more details in the future.</p>
</blockquote>
<p>The app setup requires adding <code>cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;()</code>,
we also setup hot reloading by setting the asset plugin.</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins((
            DefaultPlugins.set({
                let delay = Duration::from_millis(200);
                let watch_for_changes = bevy::asset::ChangeWatcher::with_delay(delay);
                AssetPlugin { asset_folder, watch_for_changes }
            }),
            cuicui_layout_bevy_ui::Plugin,
            bevy_inspector_egui::quick::WorldInspectorPlugin::default(),
            // You still need to add manually the chirp loaded for UiDsl!
            cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;(),
        ))
        .add_systems(Startup, setup)
        .run();</code></pre>
<p>The setup, however, is completely trivial, since it is now the loading plugin
that takes care of spawning the UI.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut cmds: Commands, serv: Res&lt;AssetServer&gt;) {
    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));

    cmds.spawn(ChirpBundle::new(serv.load(&quot;chirp_menu.chirp&quot;)));
}</code></pre>
<p>Now, we write the <code>chirp</code> file in the <code>assets/</code> folder.</p>
<p>This is fairly close to a copy/paste of the one in ???, with the distinction
that we use an <code>fn</code> template instead of a <code>code</code> block to avoid repetition for
the menu buttons.</p>
<pre><code class="language-ron">// file used in &lt;examples/chirp_menu/main.rs&gt;
fn menu_button(txt) {
    Entity(text(txt) font_size(30) named(txt) image(&quot;button.png&quot;) height(33px))
}
Root(layout(&quot;&gt;dSaS&quot;) screen_root main_margin(100) image(&quot;background.jpg&quot;)) {
    Menu(rules(310px, 100%) main_margin(40) image(&quot;board.png&quot;) column) {
        TitleCard(image(&quot;logo.png&quot;) width(100%))
        TitleCard2(image(&quot;logo.png&quot;) width(50%))
        Buttons(column rules(100%, 2*)) {
            Entity(text(&quot;CONTINUE&quot;) font_size(30) named(&quot;CONTINUE&quot;) image(&quot;button.png&quot;) height(33px))
            menu_button!(&quot;NEW GAME&quot;)
            menu_button!(&quot;LOAD GAME&quot;)
            menu_button!(&quot;SETTINGS&quot;)
            menu_button!(&quot;ADDITIONAL CONTENT&quot;)
            menu_button!(&quot;CREDITS&quot;)
            menu_button!(&quot;QUIT GAME&quot;)
        }
    }
}
</code></pre>
<p>Similarly to the <code>dsl</code>-based example, the documentation for which methods are
available is on <code>docs.rs</code> (or your local copy with <code>cargo doc</code>) for <a href="https://docs.rs/cuicui_layout_bevy_ui/0.9.0/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a>
and <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a>.</p>
<p>Try running the <code>chirp_menu</code> example and modifying <code>chirp_menu.chirp</code> to see
how it affects the layout!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-examples"><a class="header" href="#running-examples">Running examples</a></h2>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>Use the <code>cargo run --bin</code> command to list possible examples, and run them.</p>
<p>We do this because it allows us to have different dependencies between examples.</p>
<h3 id="specific-example-docs"><a class="header" href="#specific-example-docs">Specific example docs</a></h3>
<h4 id="hello_world"><a class="header" href="#hello_world"><code>hello_world</code></a></h4>
<p>The most minimal code to show usage of <code>cuicui_layout</code> using <code>cuicui_dsl</code></p>
<h4 id="simple_menu"><a class="header" href="#simple_menu"><code>simple_menu</code></a></h4>
<p>A single menu made using <code>cuicui_dsl</code>.</p>
<h4 id="chirp_menu"><a class="header" href="#chirp_menu"><code>chirp_menu</code></a></h4>
<p>A single menu supporting hot reloading made using <code>cuicui_chirp</code>.</p>
<h4 id="chirpunk"><a class="header" href="#chirpunk"><code>chirpunk</code></a></h4>
<p>A clone of the cyberpunk 2077 main menu and settings menu.</p>
<p>Demonstrates full end-to-end usage of <code>.chirp</code>, including common patterns for
managining complexity.</p>
<p>This example requires additional steps to work properly.</p>
<p>Check the <a href="../examples/./chirpunk/">example's README</a> for more details.</p>
<h4 id="dsl_and_chirp"><a class="header" href="#dsl_and_chirp"><code>dsl_and_chirp</code></a></h4>
<p>Demonstrates the equivalence between the <code>dsl!</code> macro and the <code>.chirp</code> file
format. Also used as a test to make sure it is trully equivalent.</p>
<h4 id="sprite_debug"><a class="header" href="#sprite_debug"><code>sprite_debug</code></a></h4>
<p>Demonstrates usage of <code>cuicui_layout_bevy_sprite</code>. Due to a quirk in the way
cargo resolves workspace features, the debug overlay is specifically broken for
this. You need to use the following command line to run it with the layout debug
overlay:</p>
<pre><code class="language-sh">cargo run --bin sprite_debug -p sprite_debug --features cuicui_layout/debug
</code></pre>
<h4 id="templates"><a class="header" href="#templates"><code>templates</code></a></h4>
<p>demonstrates usage of the <code>cuicui_chirp</code> templating features. See the file in
<code>assts/templates.chirp</code> for details, as most of the interesting code is in the
chirp file itself, not the rust source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chirpunk-1"><a class="header" href="#chirpunk-1">Chirpunk</a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>The cuicui cyberpunk example.</p>
<p>Inspired by <a href="https://github.com/bytestring-net/bevy-lunex"><code>bevy-lunex</code></a>'s <a href="https://github.com/IDEDARY/bevy-lunex-cyberpunk">cyberpunk example</a>.</p>
<p>This demonstrates how to create and handle a more complex menu. It has:</p>
<ul>
<li>Several screens (title screen, graphics settings, audio settings, bonus tabs)</li>
<li>Buttons with juicy hover animations</li>
<li>Nice screen effects such as background animation and bloom</li>
<li>Gamepad handling with <a href="https://lib.rs/crates/bevy-ui-navigation"><code>bevy-ui-navigation</code></a></li>
<li>Minimal data binding based on events.</li>
</ul>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Due to the nature of the assets used, I prefer not including them in this
repository. To get them, run the <code>make checkout-cyberpunk</code> make recipe.</p>
<p>The idea is to clone the bevy-lunex cyberpunk example and re-use its <code>asset</code>
directory.</p>
<p>If <code>make</code> is not an option for you, the following shell commands <em>should work</em>,
although it has only been proven to work on my machine™.</p>
<pre><code class="language-sh"># First Make sure that your working directory (PWD) is the cuicui_layout workspace root.
if not test -e CHANGELOG.md ; then
  echo &quot;your working directory (PWD) should be the cuicui_layout workspace root.&quot;
  exit 1
fi

# Create a repository for bevy-lunex-cyberpunk, without copying the files
git clone --no-checkout --depth=1 --filter=tree:0 \
    https://github.com/IDEDARY/bevy-lunex-cyberpunk.git \
    examples/chirpunk/lunex-cyberpunk-assets
# Go into bevy-lunex-cyberpunk repo and tell it to only download the 'assets' directory
cd examples/chirpunk/lunex-cyberpunk-assets
git sparse-checkout set --no-cone assets
# Check out the bevy-lunex-cyberpunk files
git checkout

# Setup the 'assets' directory in ./examples/chirpunk
cd ..
../../scripts/x_platform_ln.sh lunex-cyberpunk-assets/assets assets
cd lunex-cyberpunk-assets/assets
# add 'menus' files to the assets directory
../../../../scripts/x_platform_ln.sh ../../menus menus
cd ../../../..
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<blockquote>
<p><code>cargo run --bin chirpunk --features cuicui_layout/debug</code></p>
<p>(the feature flag is optional)</p>
</blockquote>
<p>Use <code>--no-default-features</code> to not spawn the <code>bevy-inspector-egui</code> world inspector.
And use <code>--features advanced_logging</code> to log more stuff.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Uses <code>bevy_ui</code> (through <code>cuicui_layout_bevy_ui</code>):
<ul>
<li>Bloom doesn't work on UI</li>
<li><strong>Requires a patches version of bevy for hot reloading</strong> to work (see the
repository's workspace <code>Cargo.toml</code>)</li>
</ul>
</li>
<li>Missing cuicui features:
<ul>
<li>A &quot;all overlapping&quot; <code>Distribution</code> mode, to replace some of the <code>MenuSwatch</code>
functionality and the deep nesting on the main menu background.</li>
<li>A &quot;templating&quot; feature, replacing <code>dsl::element</code></li>
<li>Single root attribute, so to avoid some nesting required for <code>bevy_ui</code> to
not panic, and generally better scene management.</li>
</ul>
</li>
<li>General 3rd party crate ideas:
<ul>
<li>Extract and generalize the <code>style.rs</code> module, which is really cool.</li>
</ul>
</li>
<li>When using mouse input, the current tab in the settings menu is not highlighted.</li>
<li>The &quot;BACK&quot; button is part of the tabs menu</li>
</ul>
<p>The end-goal is to use <code>cuicui_layout_bevy_sprite</code> instead of
<code>cuicui_layout_bevy_ui</code> as &quot;rendering backend&quot;. As we don't need <code>bevy_ui</code> for
this specific example (the only benefit of <code>bevy_ui</code> over <code>bevy_sprite</code> is
layouting, click management and borders, of which we use none), and bevy' sprite
renderer is more flexible.</p>
<p>But I wanted to start with a working example, and <code>cuicui_layout_bevy_sprite</code>
still is missing some basic features to make it useable.</p>
<p>In the future, we will add a new bin target, that re-uses most of the code but
uses the <code>dsl!</code> macro instead of chirp files.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Since this is a complex example, it needs a bit of a &quot;map&quot; so that you can
orient yourself and find the landmarks that is most relevant to you.</p>
<p>We have five modules:</p>
<ul>
<li><code>dsl</code>: <strong>The most important module</strong>. A wrapper around <code>UiDsl</code> to add to the
DSL a vocabulary specific to our own UI, such as &quot;main_menu_item&quot; or &quot;tab_button&quot;.
The &quot;method names&quot; you see used in the <code>.chirp</code> files and <code>dsl!</code> macros are
methods on <code>BevypunkDsl</code>, and <code>UiDsl</code>, and <code>LayoutDsl</code> and <code>BaseDsl</code>.
<br />
Those are methods you can call using regular rust method syntax!</li>
<li><code>animate</code>: Animation components, used for the shift-on-hover &amp; background
police car strobe lights in the title screen</li>
<li><code>colormix</code>: defines <code>color_lerp</code> to blend bevy <code>Color</code>s in HSLuv space, used
in <code>animate</code></li>
<li><code>ui_offset</code>: Simple plugin to apply object movement AFTER <code>bevy_ui</code>'s layouting
system. Used in <code>animate</code> for the shift-on-hover effect.</li>
<li><code>style</code>: A styling module. It's a way to change styling variable at runtime
throuhg the <code>style::Bevypunk</code> resource. This could also be loaded as a resource
or modified through <code>bevy-inspector-egui</code>.</li>
</ul>
<p>The <code>.chirp</code> files defining the menus are in the <code>menus</code> directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_dsl"><a class="header" href="#cuicui_dsl"><code>cuicui_dsl</code></a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_dsl/"><img src="https://docs.rs/cuicui_dsl/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_dsl</code> is a crate exposing a single trait (<a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/trait.DslBundle.html"><code>DslBundle</code></a>) and
a single macro (<a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a>) to define bevy scenes within rust code.</p>
<p>It is used in <code>cuicui</code> for UI, but can be used for any kind of scene.</p>
<h2 id="when-to-use-cuicui_dsl"><a class="header" href="#when-to-use-cuicui_dsl">When to use <code>cuicui_dsl</code>?</a></h2>
<ul>
<li>You want an <em>extremely lightweight</em> yet powerful scene definition DSL in bevy
to replace the innane <code>cmds.spawn(…).insert(…).with_children(…)</code> dance.</li>
<li>You don't care about having to re-compile the whole game each time you change
your scene.</li>
</ul>
<h2 id="how-to-use-cuicui_dsl"><a class="header" href="#how-to-use-cuicui_dsl">How to use <code>cuicui_dsl</code>?</a></h2>
<ol>
<li>Define a type that implements <code>DslBundle</code></li>
<li>Define methods with a <code>&amp;mut self</code> receiver on this type</li>
<li>Use the methods of the type in question in the <code>dsl!</code> macro</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span><span class="boring">use std::borrow::Cow;
</span>use cuicui_dsl::{dsl, DslBundle, EntityCommands};

// DslBundle requires Default impl
#[derive(Default)]
pub struct MyDsl {
    style: Style,
    bg_color: Color,
    font_size: f32,
    inner: BaseDsl,
}
impl MyDsl {
    pub fn named(&amp;mut self, name: impl Into&lt;Cow&lt;'static, str&gt;&gt;) {
        self.inner.named(name);
    }
    pub fn style(&amp;mut self, style: Style) {
        self.style = style;
    }
    pub fn bg_color(&amp;mut self, bg_color: Color) {
        self.bg_color = bg_color;
    }
    pub fn font_size(&amp;mut self, font_size: f32) {
        self.font_size = font_size;
    }
}
impl DslBundle for MyDsl {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        cmds.insert(self.style.clone());
        cmds.insert(BackgroundColor(self.bg_color));
        self.inner.insert(cmds);
        // ...
        cmds.id()
    }
}
// Now you can use `MyDsl` in a `dsl!` macro
fn setup(mut cmds: Commands) {
    let height = px(32);
    dsl! {
        &lt;MyDsl&gt;
        &amp;mut cmds.spawn_empty(),
        // The uppercase name at the start of a statement is the entity name.
        Root(style(Style { flex_direction: FlexDirection::Column, ..default()}) bg_color(Color::WHITE)) {
            Menu(style(Style { height, ..default()}) bg_color(Color::RED))
            Menu(style(Style { height, ..default()}) bg_color(Color::GREEN))
            Menu(style(Style { height, ..default()}) bg_color(Color::BLUE))
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>This seems a bit verbose, that's because you should be using <a href="https://docs.rs/crate/cuicui_layout/0.9.0"><code>cuicui_layout</code></a> and
not bevy's native layouting algorithm (flexbox) for layouting :)</p>
<p>The <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/macro.dsl.html">docs.rs page</a> already has extensive documentation on the <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> macro,
<strong>with a lot of examples</strong>.</p>
<ul>
<li><a href="https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html">https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html</a></li>
</ul>
<p>The short of it is:</p>
<p><code>dsl!</code> accepts three arguments:</p>
<ol>
<li>(optional) the <code>DslBundle</code> type you want to use as &quot;builder&quot; for the DSL.</li>
<li>The <code>&amp;mut EntityCommands</code> to spawn the scene into.</li>
<li>A single statement</li>
</ol>
<p>What is a statement? A statement is:</p>
<ul>
<li>An <code>EntityName</code> (which is a single identifier) followed by either:
<ul>
<li>several methods within <code>(parenthesis)</code></li>
<li>several children statements within <code>{curly braces}</code></li>
<li>both of the above</li>
</ul>
</li>
</ul>
<p>A statement creates a <code>Default::default()</code> of the choosen <code>DslBundle</code> type.
Then, each mehtod within parenthesis is called on the choosen <code>DslBundle</code> type.
Finally, an entity is spawned using the <code>DslBundle::insert</code> method on the
thus-constructed <code>DslBundle</code>.
The spawned entity has the <code>Name</code> component set to the identifier provided for <code>EntityName</code>.</p>
<p>Children are added to that entity if child statements are specified within
braces.</p>
<p>Still confused about it? I encourage you to either look at the <a href="https://github.com/nicopap/cuicui_layout/tree/cuicui_dsl-v0.9.0/examples">examples</a>
or check the docs at:</p>
<ul>
<li><a href="https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html">https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html</a></li>
</ul>
<h3 id="dsl-specific-documentation"><a class="header" href="#dsl-specific-documentation">DSL-specific documentation</a></h3>
<p>Since <code>dsl!</code> is just a wrapper around method calls, you can refer to the <code>docs.rs</code>
page for the <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/trait.DslBundle.html"><code>DslBundle</code></a> implementation you chose to use in your <code>dsl!</code>.</p>
<h3 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h3>
<h4 id="behind-the-veil"><a class="header" href="#behind-the-veil">Behind the veil</a></h4>
<p>The <code>dsl!</code> macro is basically a way to translate an imperative sequential API
into a declarative functional API.</p>
<p>When you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::dsl;
<span class="boring">fn sys(mut cmds: EntityCommands) {
</span>dsl! {
    &lt;BlinkDsl&gt;
    &amp;mut cmds,
    Root {
        FastBlinker(frequency(0.5))
        SlowBlinker(amplitude(2.) frequency(3.0))
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> macro translates it into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span><span class="boring">fn sys(mut cmds: EntityCommands) {
</span>let mut root = BlinkDsl::default();
root.named(&quot;Root&quot;);
root.node(&amp;mut cmds, |cmds| {
    let mut fast_blinker = BlinkDsl::default();
    fast_blinker.named(&quot;FastBlinker&quot;);
    fast_blinker.frequency(0.5);
    fast_blinker.insert(&amp;mut cmds.spawn_empty());

    let mut slow_blinker = BlinkDsl::default();
    slow_blinker.named(&quot;SlowBlinker&quot;);
    slow_blinker.amplitude(2.);
    slow_blinker.frequency(3.0);
    slow_blinker.insert(&amp;mut cmds.spawn_empty());
});
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/trait.DslBundle.html#tymethod.insert"><code>DslBundle::insert</code></a> impl of <code>BlinkDsl</code> takes care of converting itself
into a set of components it will insert on an entity.</p>
<p>See the <a href="https://docs.rs/cuicui_dsl/0.9.0/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> documentation for more details and examples.</p>
<h4 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h4>
<p>The <code>cuicui</code> crates <em>compose</em> different <code>DslBundle</code>s with a very filthy trick.</p>
<p>Using <code>DerefMut</code>, you can get both the methods of your custom <code>DslBundle</code> and
the methods of another <code>DslBundle</code> embedded into your custom <code>DslBundle</code>
(and this works recursively).</p>
<p>Use the bevy <code>Deref</code> and <code>DerefMut</code> derive macros to accomplish this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::DslBundle;

// `= ()` means that if not specified, there is no inner DslBundle
#[derive(Default, Deref, DerefMut)]
pub struct MyDsl&lt;D = ()&gt; {
    #[deref]
    inner: D,
    style: Style,
    bg_color: Color,
    font_size: f32,
}
impl&lt;D: DslBundle&gt; DslBundle for MyDsl&lt;D&gt; {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        cmds.insert(self.style.clone());
        // ... other components to insert ...
        // Always call the inner type at the end so that insertion order follows
        // the type declaration order.
        self.inner.insert(cmds)
    }
}
// Both the methods defined on `MyDsl`
// and the provided `D` are available in the `dsl!` macro for `&lt;MyDsl&lt;D&gt;&gt;`
<span class="boring">}</span></code></pre></pre>
<h4 id="performance"><a class="header" href="#performance">Performance</a></h4>
<p>The downside of the aforementioned trick is the size of your <code>DslBundle</code>s.
Very large <code>DslBundle</code>s tend to generate a lot of machine code just to move them
in and out of functions.</p>
<p>Try keeping the size of your <code>DslBundle</code>s down using <code>bitsets</code> crates such as
<a href="https://docs.rs/enumset/latest/enumset/"><code>enumset</code></a> or <a href="https://docs.rs/bitflags/latest/bitflags/"><code>bitflags</code></a> instead of <code>bool</code> fields.</p>
<p>Consider also <code>Box</code>ing some large components such as <code>Style</code> to avoid the cost of
moving them.</p>
<h4 id="storing-a-dynamic-set-of-bundles-in-your-dslbundle"><a class="header" href="#storing-a-dynamic-set-of-bundles-in-your-dslbundle">Storing a dynamic set of bundles in your <code>DslBundle</code></a></h4>
<p>If you are a lazy butt like me, you don't need to add a field per bundles/component
managed by your <code>DslBundle</code>, you can store a <code>Vec</code> of bundle spawners as follow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::{EntityCommands, DslBundle};

#[derive(Default)]
pub struct MyDynamicDsl(Vec&lt;Box&lt;dyn FnOnce(&amp;mut EntityCommands)&gt;&gt;);

impl MyDynamicDsl {
    pub fn named(&amp;mut self, name: &amp;str) {
        let name = name.to_string();
        self.0.push(Box::new(move |cmds| {cmds.insert(Name::new(name));}));
    }
    pub fn transform(&amp;mut self, transform: Transform) {
        self.0.push(Box::new(move |cmds| {cmds.insert(transform);}));
    }
    pub fn style(&amp;mut self, style: Style) {
        self.0.push(Box::new(move |cmds| {cmds.insert(style);}));
    }
    // ... Hopefully you get the idea ...
}
impl DslBundle for MyDynamicDsl {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        for spawn in self.0.drain(..) {
            spawn(cmds);
        }
        cmds.id()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp"><a class="header" href="#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp">What is the relationship between <code>cuicui_dsl</code> and <code>cuicui_chirp</code>?</a></h2>
<p><code>cuicui_dsl</code> is a macro (<code>dsl!</code>), while <code>cuicui_chirp</code> is a scene file format,
parser and bevy loader. <code>cuicui_chirp</code> builds on top of <code>cuicui_dsl</code>, and has
different features than <code>cuicui_dsl</code>. Here is a feature matrix:</p>
<div class="table-wrapper"><table><thead><tr><th>features</th><th><code>cuicui_dsl</code></th><th><code>cuicui_chirp</code></th></tr></thead><tbody>
<tr><td>statements &amp; methods</td><td>✅</td><td>✅</td></tr>
<tr><td><code>code</code> blocks with in-line rust code</td><td>✅</td><td></td></tr>
<tr><td><code>code</code> calling registered functions</td><td></td><td>✅</td></tr>
<tr><td><code>fn</code> templates</td><td>rust<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td></tr>
<tr><td>import from other files</td><td>rust<sup class="footnote-reference"><a href="#2">2</a></sup></td><td></td></tr>
<tr><td>hot-reloading</td><td></td><td>✅</td></tr>
<tr><td>reflection-based methods</td><td></td><td>✅</td></tr>
<tr><td>special syntax for colors, rules</td><td></td><td>✅</td></tr>
<tr><td>lightweight</td><td>✅</td><td></td></tr>
</tbody></table>
</div>
<p>You may use <code>cuicui_dsl</code> in combination with <code>cuicui_chirp</code>, both crates fill
different niches.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>A <code>fn</code> template is equivalent to defining a function that accepts an
<a href="https://docs.rs/bevy/0.11/bevy/ecs/system/struct.EntityCommands.html"><code>EntityCommands</code></a> and directly calls <code>dsl!</code> with it
</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::{dsl, EntityCommands};

fn rust_template(cmds: &amp;mut EntityCommands, serv: &amp;AssetServer) {
  dsl! {
    cmds,
    Root(screen_root column) {
      Menu(image(&amp;serv.load(&quot;menu1.png&quot;)))
      Menu(image(&amp;serv.load(&quot;menu2.png&quot;)))
    }
  }
}
<span class="boring">}</span></code></pre></pre>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>You can — of course — import functions from other files in rust and use
that instead.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_chirp"><a class="header" href="#cuicui_chirp"><code>cuicui_chirp</code></a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_chirp/"><img src="https://docs.rs/cuicui_chirp/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_chirp</code> defines a file format for text-based bevy scene description.</p>
<p>It is used in <code>cuicui</code> for UI, but can describe any kind of scene.</p>
<p>It includes:</p>
<ul>
<li>A parser for the file format.</li>
<li>A bevy loader to load those files in bevy, with <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/loader/struct.Plugin.html"><code>loader::Plugin</code></a>.</li>
<li>A trait (<a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>) to use your own type's methods as chirp methods</li>
<li>A macro to automatically implement this trait (<a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a>)</li>
</ul>
<p>The syntax is very close to that of <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a>'s <code>dsl!</code> macro,
with <a href="../chirp/index.html#import-statements">some additions</a>.</p>
<h2 id="when-to-use-cuicui_chirp"><a class="header" href="#when-to-use-cuicui_chirp">When to use <code>cuicui_chirp</code>?</a></h2>
<ul>
<li>You want a powerful and extensible scene definition format for bevy
to replace the innane <code>cmds.spawn(…).insert(…).with_children(…)</code> dance.</li>
<li>You want quick iteration time using hot reloading and useful error messages.</li>
<li>You want to minimize the amount of rust code you write to manage scenes.</li>
<li>You want a re-usable scene definition format.</li>
</ul>
<p>Be aware that <code>cuicui_chirp</code>, by its nature, is not a small dependency.
Consider using <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> if dependency size matters to you.</p>
<p>Also, as of <code>0.10</code>, <code>cuicui_chirp</code> doesn't support WASM for image and font assets.</p>
<h2 id="how-to-use-cuicui_chirp"><a class="header" href="#how-to-use-cuicui_chirp">How to use <code>cuicui_chirp</code>?</a></h2>
<h3 id="cargo-features"><a class="header" href="#cargo-features">Cargo features</a></h3>
<ul>
<li><strong><code>fancy_errors</code></strong> (default): Print parsing error messages in a nicely formatted way.</li>
<li><strong><code>macros</code></strong> (default): Define and export the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a> macro</li>
<li><strong><code>load_font</code></strong> (default): load <code>Handle&lt;Font&gt;</code> as method argument</li>
<li><strong><code>load_image</code></strong> (default): load <code>Handle&lt;Image&gt;</code> as method argument</li>
<li><strong><code>trace_parser</code></strong>: log very verbose parsing information</li>
</ul>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p><code>cuicui_chirp</code> reads files ending with the <code>.chirp</code> extension. To load a <code>.chirp</code>
file, use <code>ChirpBundle</code> as follow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(feature = &quot;doc_and_test&quot;)] mod test {
</span><span class="boring">use cuicui_chirp::__doc_helpers::*; // ignore this line pls
</span>use bevy::prelude::*;
use cuicui_chirp::ChirpBundle;

fn setup(mut cmds: Commands, assets: Res&lt;AssetServer&gt;) {
    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));
    cmds.spawn(ChirpBundle::from(assets.load(&quot;my_scene.chirp&quot;)));
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>You need however to add the loader pluging (<a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/loader/struct.Plugin.html"><code>loader::Plugin</code></a>) for this to work.
The plugin is parametrized over the DSL type.
The DSL type needs to implement the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a> trait.</p>
<p>Here is an example using <code>cuicui_layout_bevy_ui</code>'s DSL:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#[cfg(feature = &quot;doc_and_test&quot;)] mod test {
</span><span class="boring">use cuicui_chirp::__doc_helpers::*; // ignore this line pls
</span><span class="boring">fn setup() {}
</span>use bevy::prelude::*;
use cuicui_layout_bevy_ui::UiDsl;

fn main() {
    App::new()
      .add_plugins((
        DefaultPlugins,
        cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;(),
      ))
      .add_systems(Startup, setup)
      .run();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dsl-specific-documentation-1"><a class="header" href="#dsl-specific-documentation-1">DSL-specific documentation</a></h3>
<p>The identifiers within parenthesis are methods on the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>.</p>
<p>Since the <code>chirp</code> format is a wrapper over a <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>, refer to the methods
on the <code>ParseDsl</code> impl you added as <code>loader::Plugin</code>.</p>
<h3 id="making-a-dslbundle-compatible-with-cuicui_chirp"><a class="header" href="#making-a-dslbundle-compatible-with-cuicui_chirp">Making a <code>DslBundle</code> compatible with <code>cuicui_chirp</code></a></h3>
<p>Let's re-use the example in <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> and extend it to work with <code>cuicui_chirp</code>.</p>
<p>We had a <code>MyDsl</code> that implements <code>DslBundle</code>, now we need to also implement <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>
for it. So that methods are accessible in <code>ParseDsl</code>, use the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a>
attribute macro, and add it to the <code>impl</code> block where all the DSL's methods are
defined:</p>
<pre><code class="language-diff">     font_size: f32,
 }
+#[cuicui_chirp::parse_dsl_impl]
 impl MyDsl {
     pub fn style(&amp;mut self, style: Style) {
         self.style = style;
</code></pre>
<p>Yep, for the simple case that's it. Just avoid panicking inside methods if you
want to take advantage of hot reloading.</p>
<h3 id="chirp-file-format"><a class="header" href="#chirp-file-format"><code>.chirp</code> file format</a></h3>
<p>The basic syntax is similar to the <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> <code>dsl!</code> macro.</p>
<p>One major difference is that <code>code</code> blocks are replaced with a function registry.
You can register a function using the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/loader/struct.WorldHandles.html"><code>WorldHandles</code></a> resource. Registered
functions are global to all chirp files loaded using <code>cuicui_chirp</code>.</p>
<p>The other differences are the addition of import statements (<code>use</code>),
template definitions (<code>fn</code>), and template calls (<code>template!()</code>).</p>
<h4 id="import-statements"><a class="header" href="#import-statements">Import statements</a></h4>
<p>They are currently not implemented, so please proceed to the next section.</p>
<h4 id="template-definitions"><a class="header" href="#template-definitions">Template definitions</a></h4>
<p>chirp files admit a series of <code>fn</code> definitions at the very beginning of the
file. A <code>fn</code> definition looks very similar to rust function definitions.
It has a name and zero or several parameters. Their body is a single statement:</p>
<pre><code class="language-ron">// file: &lt;scene.chirp&gt;
// template name
//   ↓
// vvvvvv
fn spacer() {
	Spacer(height(10px) width(10%) bg(coral))
}
//             parameter
// template name  ↓
//    ↓           ↓
// vvvvvv vvvvvvvvvvv
fn button(button_text) {
    Entity(named(button_text) width(95%) height(200px) bg(purple) row) {
        ButtonText(text(button_text) rules(0.5*, 0.5*))
    }
}
</code></pre>
<p>You can call a template like you would call a rust macro, by writing the template
name followed by <code>!</code> and parenthesis:</p>
<pre><code class="language-ron">// file: &lt;scene.chirp&gt; (following)
Menu(screen_root row bg(darkgrey)) {
    TestSpacer(width(30%) height(100px) bg(pink))
    spacer!()
    button!(&quot;Hello world&quot;)
}
</code></pre>
<p>When a template is called, it will be replaced by the single root statement
defined as body of the <code>fn</code> definition for that template.</p>
<h4 id="template-extras"><a class="header" href="#template-extras">Template Extras</a></h4>
<p>Template calls can be followed by <strong>template extras</strong>.</p>
<pre><code class="language-ron">// file: &lt;scene.chirp&gt; (following)
Menu(screen_root row bg(darkgrey)) {
    TestSpacer(width(30%) height(100px) bg(pink))

    // Additional method list after the template arguments list
    //       vvvvvvvvvvvvvvvvvvvvvv
    spacer!()(width(50%) bg(coral))

    // Both additional methods and additional children added after the argument list
    //                    vvvvvvvvvv
    button!(&quot;Hello world&quot;)(column) {
        MoreChildren(text(&quot;Hello&quot;))
        MoreChildren(text(&quot;World&quot;))
    }
}
</code></pre>
<p>The additional methods will be added at the end of template's root statement
method list. While the additional children statements will be added as children
of the template's root statement.</p>
<h4 id="parameter-substitution"><a class="header" href="#parameter-substitution">Parameter substitution</a></h4>
<blockquote>
<p><strong>Note</strong>
&quot;argument&quot; here may refer to two things: (1) the value passed as
argument to a template, in <code>template!(foo_bar)</code>, <code>foo_bar</code> is an argument.
(2) arguments passed to <em>methods</em>, in <code>Entity(text(method_argument))</code>,
<code>method_argument</code> is a method argument.</p>
<p>The name declared between parenthesis in the <code>fn</code> name is a <strong>parameter</strong>. In
<code>fn button(button_text)</code>, <code>button_text</code> is a template parameter.</p>
</blockquote>
<p>When a template is called, the body of the <code>fn</code> is inserted where the call
is made, arguments passed to the template are inlined within the statement
of the template body.</p>
<p>Please pay close attention to how parameters are inlined:</p>
<ul>
<li>Parameters are only inlined <strong>in method arguments</strong></li>
<li>Parameters are <strong>not inlined within quotes</strong></li>
<li>Parameters are only inlined <strong>if they are the whole argument</strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th><strong>❗ Compatibility Notice ❗</strong></th></tr></thead><tbody>
<tr><td>In the future, parameters will be allowed in more contexts: <ul><li>in method lists (such as <code>Entity(parameter)</code>)</li><li>As template names (such as <code>parameter!()</code>)</li><li>Embedded in a more complex method argument (such as <code>Entity(mehod({ width: parameter }))</code>)</li></ul></td></tr>
<tr><td>To avoid painfull breaking changes, avoid naming parameters the same as DSL methods or templates.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ron">fn button(button_text) {
    // Will spawn an entity without name, with tooltip set to whatever
    // was passed to `button!`.
    Entity(tooltip(button_text) width(95%) height(200px) bg(purple) row) {
        // Will spawn an entity named &quot;button_text&quot; with text &quot;button_text&quot;
        button_text(text(&quot;button_text&quot;) rules(0.5*, 0.5*))

        // Current limitation:
        // `gizmo` method will be called with `GizmoBuilder(button_text)` as first
        // argument and whatever was passed to `button!` as second argument
        Gizmo(gizmo(GizmoBuilder(button_text), button_text) rules(0.5*, 0.5*))
    }
}
</code></pre>
<h3 id="tips-and-tricks-1"><a class="header" href="#tips-and-tricks-1">Tips and tricks</a></h3>
<p>See the <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl_impl/index.html">dedicated documentation page</a> for all available
configuration options on <code>parse_dsl_impl</code>.</p>
<h4 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h4>
<p>Remember the inheritance trick from <a href="https://lib.rs/crates/cuicui_dsl#inheritance"><code>cuicui_dsl</code></a>? <code>parse_dsl_impl</code> is
compatible with it. Use the <code>delegate</code> argument to specify the field to which
to delegate methods not found on the <code>MyDsl</code> impl.</p>
<pre><code class="language-rust ignore">// pub struct MyDsl&lt;D = ()&gt; {
//     #[deref]
//     inner: D,
// }
#[parse_dsl_impl(delegate = inner)]
impl&lt;D: DslBundle&gt; MyDsl&lt;D&gt; {
    // ...
}</code></pre>
<p>See <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse_dsl_impl/fn.delegate.html"><code>parse_dsl_impl::delegate</code></a>.</p>
<h4 id="reflectdsl"><a class="header" href="#reflectdsl"><code>ReflectDsl</code></a></h4>
<p>Unlike <code>cuicui_dsl</code>, it is possible to use <a href="https://docs.rs/bevy/0.11/bevy/reflect/trait.Reflect.html"><code>Reflect</code></a> to define DSLs. See the
<a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/reflect/struct.ReflectDsl.html"><code>ReflectDsl</code></a> docs for details.</p>
<h4 id="custom-parsers"><a class="header" href="#custom-parsers">Custom parsers</a></h4>
<p>Since <code>.chirp</code> files are in text format, we need to convert text into method
arguments. <code>parse_dsl_impl</code> parses differently method arguments depending on
their type.</p>
<p>See [<code>parse_dsl_impl::type_parsers</code>] for details.</p>
<h2 id="what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp-1"><a class="header" href="#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp-1">What is the relationship between <code>cuicui_dsl</code> and <code>cuicui_chirp</code>?</a></h2>
<p><code>cuicui_dsl</code> is a macro (<code>dsl!</code>), while <code>cuicui_chirp</code> is a scene file format,
parser and bevy loader. <code>cuicui_chirp</code> builds on top of <code>cuicui_dsl</code>, and has
different features than <code>cuicui_dsl</code>. Here is a feature matrix:</p>
<div class="table-wrapper"><table><thead><tr><th>features</th><th><code>cuicui_dsl</code></th><th><code>cuicui_chirp</code></th></tr></thead><tbody>
<tr><td>statements &amp; methods</td><td>✅</td><td>✅</td></tr>
<tr><td><code>code</code> blocks with in-line rust code</td><td>✅</td><td></td></tr>
<tr><td><code>code</code> calling registered functions</td><td></td><td>✅</td></tr>
<tr><td><code>fn</code> templates</td><td>rust</td><td>✅</td></tr>
<tr><td>import from other files</td><td>rust</td><td></td></tr>
<tr><td>hot-reloading</td><td></td><td>✅</td></tr>
<tr><td>reflection-based methods</td><td></td><td>✅</td></tr>
<tr><td>special syntax for colors, rules</td><td></td><td>✅</td></tr>
<tr><td>lightweight</td><td>✅</td><td></td></tr>
</tbody></table>
</div>
<p>You may use <code>cuicui_dsl</code> in combination with <code>cuicui_chirp</code>, both crates fill
different niches.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout"><a class="header" href="#cuicui_layout"><code>cuicui_layout</code></a></h1>
<p><a href="https://nicopap.github.io/cuicui_layout/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_layout/"><img src="https://docs.rs/cuicui_layout/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_layout</code> is a very primitive layouting algorithm implemented in bevy for bevy.</p>
<p>It is similar to CSS, but without the headache. The philosophy is:</p>
<blockquote>
<p><strong>You can always predict how it will look like</strong></p>
</blockquote>
<p><code>cuicui_layout</code> is fully independent from other cuicui crates, you can disable
all default feature and have a bare-bone plugin that only adds layouting components
and systems to your bevy game.</p>
<p>However, <code>cuicui_layout</code> also integrates with <code>cuicui_dsl</code> and <code>cuicui_chirp</code>.</p>
<p>See their respective documentation pages for why you'd want to use them as well.</p>
<ul>
<li><a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a></li>
<li><a href="https://lib.rs/crates/cuicui_chirp"><code>cuicui_chirp</code></a></li>
</ul>
<h2 id="when-to-use-cuicui_layout"><a class="header" href="#when-to-use-cuicui_layout">When to use <code>cuicui_layout</code>?</a></h2>
<p><code>cuicui_layout</code> is always a better choice over Flexbox, the default bevy UI
layouting algorithm. I'm however not claiming that it is better than other
similar non-flexbox layouting algorithm.</p>
<p>Here is some reasons you'd prefer <code>cuicui_layout</code> over other layouting
algorithms:</p>
<ul>
<li>Friendly algo with less things to keep in your head and good defaults.</li>
<li>Uses and takes full advantage of the bevy ECS.</li>
<li>Only controls <code>LayoutRect</code>, not <code>Transform</code>, you need to add a system that sets
<code>Transform</code> based on <code>LayoutRect</code>.</li>
<li>Fully flexible and extensible, can be used with <code>bevy_ui</code>, <code>bevy_sprite</code>, your own stuff.</li>
<li>Helpful and fully detailed error messages when things are incoherent or broken.
As opposed to FlexBox, which goes &quot;this is fine 🔥🐶🔥&quot; and leaves you to guess
why things do not turn out as expected.</li>
<li>This is a single-pass algo, so more efficient than flexbox.</li>
<li>An extensive debugging overlay.</li>
</ul>
<h2 id="how-to-use-cuicui_layout"><a class="header" href="#how-to-use-cuicui_layout">How to use <code>cuicui_layout</code>?</a></h2>
<h3 id="cargo-features-1"><a class="header" href="#cargo-features-1">Cargo features</a></h3>
<ul>
<li><strong><code>debug</code></strong>: Enable the debug overlay</li>
<li><strong><code>reflect</code></strong> (default): Enable <code>bevy_reflect</code> impls for layout components.</li>
<li><strong><code>chirp</code></strong> (default): Enable <a href="https://lib.rs/crates/cuicui_chirp">chirp</a> <a href="https://docs.rs/cuicui_chirp/0.9.0/cuicui_chirp/parse/trait.ParseDsl.html"><code>ParseDsl</code></a> implementation for <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a></li>
<li><strong><code>dsl</code></strong> (default): Define and export <code>LayoutDsl</code> <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/trait.DslBundle.html"><code>DslBundle</code></a> impl for the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/macro.dsl.html"><code>dsl!</code></a> macro</li>
</ul>
<h3 id="layouting-1"><a class="header" href="#layouting-1">Layouting</a></h3>
<p><code>cuicui_layout</code> exposes the following <a href="https://docs.rs/bevy/0.11/bevy/ecs/component/trait.Component.html"><code>Component</code></a>s to control layouting:</p>
<ul>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Node.html"><code>Node</code></a>: A layout node, either a container holding other nodes as bevy
<a href="https://docs.rs/bevy/0.11/bevy/hierarchy/struct.Children.html"><code>Children</code></a> or a leaf node.</li>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.Root.html"><code>Root</code></a>: The root of a node hierarchy. You may have several, all computations
start from the root.</li>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.ScreenRoot.html"><code>ScreenRoot</code></a>: If you add this component to a <code>Root</code> entity, it will keep
the same size as the camera with the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.LayoutRootCamera.html"><code>LayoutRootCamera</code></a> component.</li>
</ul>
<p>See the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Rule.html"><code>Rule</code></a> and <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.Container.html"><code>Container</code></a> documentation for detailed explanation.</p>
<p>In short: a <code>Node</code> has independent <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Rule.html"><code>Rule</code></a>s on the <code>x</code> and <code>y</code> axis. When the
node is a <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.Container.html"><code>Container</code></a>, it also has additional properties that manages how
children are distributed within the container.</p>
<p>Those additional properties are:</p>
<ul>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Flow.html"><code>Flow</code></a>: The direction in which the children are distributed</li>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Alignment.html"><code>Alignment</code></a>: Where on the cross axis are nodes aligned.</li>
<li><a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Distribution.html"><code>Distribution</code></a>: How to distribute the children of this container.</li>
<li><code>margin</code>: How much margin to put on main and cross axis</li>
</ul>
<p>By default, items are aligned at the center of the container, distributed
on the flow direction evenly within the container.</p>
<p>A <code>Rule</code> tells the size of the <code>Node</code>, it can depend on the size of its children,
the size of its parent or be a fixed value.</p>
<p>There isn't more to it, that's pretty much all of <code>cuicui_layout</code>.
If this wasn't clear enough please read the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Rule.html"><code>Rule</code></a> and <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.Container.html"><code>Container</code></a> documentation.</p>
<h3 id="content-sized"><a class="header" href="#content-sized">Content-sized</a></h3>
<p>It is possible to size leaf nodes based on components present on the same entity.</p>
<p>Use the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/index.html"><code>content_sized</code></a> traits to do that.</p>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<p><code>cuicui_layout</code> has an integrated debugger. Enable it with the <code>cuicui_layout/debug</code>
cargo feature.</p>
<p>The debugger is an overlay displaying the extent of <code>Node</code>s and the direction
of their rules.</p>
<h2 id="why-not-flexbox"><a class="header" href="#why-not-flexbox">Why not Flexbox</a></h2>
<p>You are writing text to get 2d visual results on screen.
The translation from text to screen should be trivial, easy to do in your head.
Otherwise you need visual feedback to get what you want.
Bevy, even with hot reloading or <a href="https://docs.rs/bevy-inspector-egui/latest/bevy_inspector_egui/index.html"><code>bevy-inspector-egui</code></a>
will always have extremely slow visual feedback.</p>
<p>Flexbox has too many parameters and depends on implicit properties of UI elements,
it is not possible to emulate it in your head.</p>
<p>cuicui's layout, in contrast to Flexbox is easy to fit in your head.
In fact, I will forecefully push cuicui's layout algorithm in your head
in two short bullet points.</p>
<ul>
<li>A node can be a <code>Node::Container</code> and distribute its children
along a <code>Direction</code> either by evenly spacing them (<code>Distribution::FillMain</code>)
or putting them directly one after another (<code>Distribution::Start</code>).</li>
<li>A <code>Container</code>'s size can be expressed as a static value, a fraction
of the size of what contains it, or a multiple of what it contains.</li>
<li>The content of a <code>Container</code> can be <code>Alignment</code> to the start, end or center
of its parent (by default it's centered).</li>
</ul>
<p>That's it. There are some edge cases, but cuicui will <del>yell at you</del>
tell you nicely when you hit them and tell you how to handle them properly.</p>
<h3 id="flexbox-faq"><a class="header" href="#flexbox-faq">Flexbox FAQ</a></h3>
<p><strong>Q</strong>: Where is <code>padding</code>?
<br><strong>A</strong>: <code>padding</code> is equivalent to <code>margin</code> in cuicui_layout. <code>margin</code> and <code>border</code>
doesn't make conceptual sense.</p>
<p><strong>Q</strong>: Why not call it <code>padding</code> then?
<br><strong>A</strong>: Look at the dictionary definition of &quot;margin&quot; and &quot;padding&quot;.</p>
<p><strong>Q</strong>: How do I center a node?
<br><strong>A</strong>: nodes are centered by default, make sure the parent's container size
has the expected size.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_direction</code>?
<br><strong>A</strong>: use <code>row</code> and <code>column</code></p>
<p><strong>Q</strong>: What are the equivalents of <code>column-reverse</code> and <code>row-reverse</code>?
<br><strong>A</strong>: None. Use <code>Alignment::End</code> and swap your elements! Note that the <code>*-reverse</code>
flows in flexbox are very useful for internationalization. However,
when making a game, it is not enough to just swap the elements! Artistic control is
paramount and internationalization needs to be taken as a whole in the context of the UI.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_wrap</code>?
<br><strong>A</strong>: None, do you really need it?</p>
<p><strong>Q</strong>: What is the equivalent of <code>align_item</code>, <code>align_self</code>, <code>align_content</code>, <code>justify_content</code>?
<br><strong>A</strong>: After 5 years of working with CSS, I still have no clue which one does what,
and whether they really do anything, so I won't adventure an asnwer.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_grow</code>, <code>flex_shrink</code>, <code>flex_basis</code>, <code>gap</code>?
<br><strong>A</strong>: Do you even know what they do?</p>
<p><strong>Q</strong>: Why can't child container overflow their parents?
<br><strong>A</strong>: It's likely you didn't expect this, so we report it as an error.</p>
<p><strong>Q</strong>: How do I make a grid?
<br><strong>A</strong>: <code>cuicui_layout</code> is currently not capable of managing a grid of nodes.
This might be added in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout-debug-view"><a class="header" href="#cuicui_layout-debug-view"><code>cuicui_layout</code> debug view</a></h1>
<p><code>cuicui_layout</code> has a &quot;debug&quot; mode. It gives a visual representation of container
and node sizes.</p>
<p><img src="https://user-images.githubusercontent.com/26321040/272255534-4cb44a1f-09c9-414e-870c-f5ebc3a468f6.jpg" alt="A screenshot of the cyberpunk menu with container outlines" /></p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ul>
<li>While the debug overlay is up, gizmos cannot be used by other plugins</li>
<li>This is only tested with <code>cuicui_layout_bevy_ui</code> and <code>cuicui_layout_bevy_sprite</code>
(I can't implement a debug view for your personal custom UI :P)</li>
<li>The debug overlay use the bevy <a href="https://docs.rs/bevy/0.11/bevy/render/view/struct.RenderLayers.html"><code>RenderLayers</code></a> nº16 and camera order 255 to draw gizmos</li>
</ul>
<h2 id="how-to-use-the-debug-view"><a class="header" href="#how-to-use-the-debug-view">How to use the debug view?</a></h2>
<p>Enable the <code>cuicui_layout/debug</code> cargo feature.</p>
<pre><code class="language-sh">cargo run --features cuicui_layout/debug
</code></pre>
<h3 id="debug-view-mode"><a class="header" href="#debug-view-mode">Debug view mode</a></h3>
<p>There are several view modes, you cycle through them by pressing the space bar:</p>
<ul>
<li><strong>nothing</strong> (default): There is no additional informations displayed</li>
<li><strong>outlines</strong>: Displays the outline of each <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/struct.Container.html"><code>Container</code></a> and <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Node.html"><code>Node</code></a> visible
on screen, with a different color</li>
<li><strong>outlines and rules</strong>: In addition to the outline, display each node's vertical
and horizontal <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/enum.Rule.html"><code>Rule</code></a>s.
<ul>
<li>Arrows pointing outwards left and right mean the horizontal size (width) depends on
the size of the parent of the node.</li>
<li>Arrows pointing inwards left and right mean the horizontal size (width) depends on
the size of the children of the node.</li>
<li>The absence of arrows indicate the node has a fixed size.</li>
<li>Arrows going up and down indicate the rules for the vertical size (height).</li>
</ul>
</li>
</ul>
<h3 id="debug-view-configuration"><a class="header" href="#debug-view-configuration">Debug view configuration</a></h3>
<p>The debug view can be programmatically manipulated using the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/debug/struct.Options.html"><code>Options</code></a> <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/trait.Resource.html"><code>Resource</code></a>.</p>
<h4 id="display-invisible-layouts"><a class="header" href="#display-invisible-layouts">Display invisible layouts</a></h4>
<p>The debug view does not display information about <code>Container</code>s with
a <code>ComputedVisibility</code> component returning <code>vis.is_visible() == false</code>.</p>
<p>Set the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/debug/struct.Options.html#structfield.show_hidden"><code>Options.show_hidden</code></a> field to <code>true</code> to display outlines even if the
<code>ComputedVisibility</code> is <code>false</code>.</p>
<h4 id="changeremove-the-cycling-key"><a class="header" href="#changeremove-the-cycling-key">Change/Remove the cycling key</a></h4>
<p>Maybe your game makes heavy use of the space key (I've heard that some plateformers use
the space key for a common action, would you belive it?) and you don't want to cycle
through the debug views each time space is pressed.</p>
<p>You can set the <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/debug/struct.Options.html#structfield.input_map"><code>Options.input_map</code></a> value to something else:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;cuicui_layout/debug&quot;)]
fn debug_toggle(mut opts: ResMut&lt;cuicui_layout::debug::Options&gt;) {
  opts.input_map.cycle_debug_flag = KeyCode::X;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="invert-y-axis-direction"><a class="header" href="#invert-y-axis-direction">Invert Y axis direction</a></h4>
<p>Confusingly, <code>bevy_ui</code> has a downward Y axis, while <code>bevy_sprite</code> has an upward
Y axis.</p>
<p>You can configure what Y axis direction the debug overlay uses by setting the
<a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/debug/struct.Options.html#structfield.screen_space"><code>Options.screen_space</code></a> field.</p>
<p>If you are using <code>cuicui_layout_bevy_ui</code>, this should be automatically set to
<code>true</code> for you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout-content-sized-nodes"><a class="header" href="#cuicui_layout-content-sized-nodes"><code>cuicui_layout</code> Content sized nodes</a></h1>
<p>Leaf nodes (nodes that do not contain other nodes) may be &quot;content-sized&quot;.</p>
<p>For example, in <code>cuicui_layout_bevy_ui</code>, a leaf node containing an image may
keep the same aspect ratio as the image.</p>
<h2 id="how-to-define-content-sized-elements"><a class="header" href="#how-to-define-content-sized-elements">How to define content-sized elements?</a></h2>
<p>First off, if you are already using <code>cuicui_layout_bevy_ui</code> or
<code>cuicui_layout_bevy_sprite</code>, <strong>you don't need to do anything</strong>, those plugins
already take care of elements that should depend on the size of their content.</p>
<p>If you need to implement content-sized elements for your own UI stuff, you will
need to:</p>
<ol>
<li>Define a <a href="https://docs.rs/bevy/0.11/bevy/ecs/system/trait.SystemParam.html"><code>SystemParam</code></a> (we will refer to it as <code>MyContentSize</code>)</li>
<li>Implement <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/trait.ComputeContentParam.html"><code>ComputeContentParam</code></a> for <code>MyContentSize</code>
<ul>
<li>In <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/trait.ComputeContentParam.html#associatedtype.Components"><code>ComputeContentParam::Components</code></a>, tell which components are used to
tell content size. Use <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/struct.AnyOf.html"><code>AnyOf</code></a> if several.</li>
<li>In <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/trait.ComputeContentParam.html#tymethod.condition"><code>ComputeContentParam::condition</code></a>, tell when the size update system should run</li>
</ul>
</li>
<li>Implement <code>ComputeContentSize</code> for <code>MyContentSize</code>. <a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/trait.ComputeContentSize.html#tymethod.compute_content"><code>ComputeContentSize::compute_content</code></a>
is ran for each leaf node <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/struct.Entity.html"><code>Entity</code></a> with the provided components.
<ul>
<li>The sizes infered by the layouting algorithm is passed as the <code>set_size</code>
parameter.</li>
<li>The return value is the sizes as they should be, based on the passed <code>components</code></li>
<li>Note that the non-content-sized axis will always keep the pre-set size, regardless
of the return value.</li>
</ul>
</li>
<li>Register <code>MyContentSize</code> as a content sized element computation using
<a href="https://docs.rs/cuicui_layout/0.9.0/cuicui_layout/content_sized/trait.AppContentSizeExt.html#tymethod.add_content_sized"><code>app.add_content_sized::&lt;MyContentSize&gt;()</code></a>.</li>
</ol>
<p>And that's it!</p>
<p>The two distinct traits are required due to a limitation in the rust type system.
Trying to merge the two traits came close to unleashing Cthulhu into the world.
Do not ask me to merge them, do not open an issue for merging them, this way
lies madness.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The best examples are the <code>content_sized.rs</code> modules in <code>cuicui_layout_bevy_ui</code>
and <code>cuicui_layout_bevy_sprite</code>.</p>
<p>Please take a look at them to get an idea of the kind of code you need to write.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
