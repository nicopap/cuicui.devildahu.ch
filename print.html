<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cuicui Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="The user guide and reference of the cuicui framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="choosing_a_cuicui_crate.html"><strong aria-hidden="true">1.</strong> Choosing a cuicui crate</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">2.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/simple_menu/index.html"><strong aria-hidden="true">2.1.</strong> Using the dsl macro</a></li><li class="chapter-item expanded "><a href="../examples/chirp_menu/index.html"><strong aria-hidden="true">2.2.</strong> Using a chirp file</a></li><li class="chapter-item expanded "><a href="../examples/custom_dsl/index.html"><strong aria-hidden="true">2.3.</strong> Defining your own DSL</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Reactivity</div></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/chirpunk/index.html"><strong aria-hidden="true">3.1.</strong> chirpunk</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="../dsl/index.html"><strong aria-hidden="true">4.</strong> cuicui_dsl</a></li><li class="chapter-item expanded "><a href="../chirp/index.html"><strong aria-hidden="true">5.</strong> cuicui_chirp</a></li><li class="chapter-item expanded "><a href="../layout/index.html"><strong aria-hidden="true">6.</strong> cuicui_layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../layout/debug.html"><strong aria-hidden="true">6.1.</strong> Layout debug overlay</a></li><li class="chapter-item expanded "><a href="../layout/content_sized.html"><strong aria-hidden="true">6.2.</strong> Content-sized leaf nodes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cuicui Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cuicui-framework"><a class="header" href="#the-cuicui-framework">The <code>cuicui</code> framework</a></h1>
<p><code>cuicui</code> is a collection of crates to work with bevy scenes and making UIs in bevy.</p>
<video controls>
  <source src="https://user-images.githubusercontent.com/26321040/272480834-e964565b-44bb-4363-8955-19515624d71a.mp4" type="video/mp4">
</video>
<p>This book contains a user-focused guide on how to use the <code>cuicui</code> crates and
more reference-level documentation on what the capabilities of each crate are.</p>
<h2 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic versioning</a></h2>
<p>All crates in the <code>cuicui</code> framework follow a synchronous release model, similar
to bevy’s. However, the release cadence is independent from bevy’s.</p>
<h4 id="version-matrix"><a class="header" href="#version-matrix">Version matrix</a></h4>
<div class="table-wrapper"><table><thead><tr><th>bevy</th><th>latest supporting version</th></tr></thead><tbody>
<tr><td>0.11</td><td>0.10.1</td></tr>
<tr><td>0.10</td><td>0.3.0</td></tr>
</tbody></table>
</div>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<p><code>cuicui</code> is a playground for experiments, so use at your own risk,
it is likely that a lot of things are going to break each release.</p>
<h2 id="cuicui-crates"><a class="header" href="#cuicui-crates"><code>cuicui</code> crates</a></h2>
<p>The crates included in <code>cuicui</code> are:</p>
<ul>
<li><a href="dsl"><code>cuicui_dsl</code></a>: The <code>dsl!</code> macro and <code>DslBundle</code>.</li>
<li><a href="chirp"><code>cuicui_chirp</code></a>: A parser for files that follow the <code>dsl!</code>
syntax. It creates a scene identical to what the same text passed to the
<code>dsl!</code> macro would produce.
<br />
It also includes a bevy plugin to load <code>.chirp</code> files defined in this format.</li>
<li><a href="layout"><code>cuicui_layout</code></a>: The base algorithm and components, does not make any assumption
about how it is used, beside the requirement that layout nodes be bevy <code>Entitiy</code> and
uses <code>bevy_hierarchy</code>.</li>
<li><a href="choosing_a_cuicui_crate.html"><code>cuicui_layout_bevy_ui</code></a>: Integration with <code>bevy_ui</code>, including extension to <code>UiDsl</code>
for <code>UiImage</code>, <code>Text</code>, background images and background colors.</li>
<li><a href="choosing_a_cuicui_crate.html"><code>cuicui_layout_bevy_sprite</code></a>: <code>bevy_sprite</code> integration, supports
<code>Mesh2dHandle</code>, <code>Sprite</code> and <code>Text2d</code>. This isn’t as good as the <code>bevy_ui</code>-based integration
when it comes to content-driven sizes, but otherwise should work very much like the <code>bevy_ui</code>
integration.</li>
</ul>
<h2 id="supporting-development"><a class="header" href="#supporting-development">Supporting development</a></h2>
<p>This crate is a single person effort. I don’t get paid for it, and is generally
unsustainable. Please consider donating to make <code>cuicui</code> sustainable.</p>
<p><a href="https://github.com/sponsors/nicopap">https://github.com/sponsors/nicopap</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-which-crates-to-use"><a class="header" href="#choosing-which-crates-to-use">Choosing which crates to use</a></h1>
<p>Confused by all the cuicui crates? Understandable, there is a lot of them, with
very long names too!</p>
<p>Let’s split the task in two. Ask yourself two questions:</p>
<ul>
<li>What do I want to layout?</li>
<li>How do I want to spawn UI scene?</li>
</ul>
<p>The following sections tell you which crate to use depending on the answer.</p>
<h2 id="layouting"><a class="header" href="#layouting">Layouting</a></h2>
<p>All you want is some sort of layouting algorithm that you can keep in your head?
Then use <a href="layout"><code>cuicui_layout</code></a> without any other crates.</p>
<ul>
<li>Interested in a ready-made UI library on top of <code>bevy_ui</code>?
Then, use <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/index.html"><code>cuicui_layout_bevy_ui</code></a>.</li>
<li>Want more flexibility? Using <a href="layout"><code>cuicui_layout</code></a> on top of <code>bevy_sprite</code> will let you
integrate your UI with a lot of 3rd party crates that only work with sprites.
Then use <a href="https://docs.rs/cuicui_layout_bevy_sprite/0.10.1/cuicui_layout_bevy_sprite/index.html"><code>cuicui_layout_bevy_sprite</code></a>.</li>
<li>Using <code>cuicui_layout</code> with your own custom rendering system? Again, bare <code>cuicui_layout</code>
is what you want.</li>
</ul>
<h2 id="scene-syntax"><a class="header" href="#scene-syntax">Scene syntax</a></h2>
<p>Then you need to decide how to spawn full scenes or UI layouts.</p>
<ul>
<li>Using the default bevy syntax, with nested <code>cmds.insert(…).with_children(…)</code>?
No need to add any crate for this :P</li>
<li>Just want something a bit less verbose that the default syntax? Something
very lightweight you can use in your rust code? Don’t mind recompiling the
whole game for each UI touchups? Then use <a href="dsl"><code>cuicui_dsl</code></a>.</li>
<li>Want quick iteration times with hot reloading, an advanced scene file format
with templating, basically an actual scripting language? Ready to
sacrifice some compile time for this? Then use <a href="chirp"><code>cuicui_chirp</code></a>.</li>
</ul>
<p>The <a href="dsl/index.html#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp"><code>cuicui_dsl</code> page</a> has a comparison matrix with <a href="chirp"><code>cuicui_chirp</code></a> to give
you a more detailed idea.</p>
<p>Note that the <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/index.html"><code>cuicui_layout_bevy_ui</code></a> and <a href="https://docs.rs/cuicui_layout_bevy_sprite/0.10.1/cuicui_layout_bevy_sprite/index.html"><code>cuicui_layout_bevy_sprite</code></a> crates
have the <code>chirp</code> feature enabled by default. If you don’t care for it, then
disable it with <code>default-features = false</code>.</p>
<p>Furthermore, the integration crates depend on <code>cuicui_dsl</code> unconditionally, as
it is a very lightweight dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Now that we chose the cuicui crates we need, time to use them.</p>
<p>For illustration, we assume that we went with <code>cuicui_layout_bevy_ui</code>.</p>
<h2 id="adding-the-selected-crates"><a class="header" href="#adding-the-selected-crates">Adding the selected crates</a></h2>
<pre><code class="language-toml">[dependencies]
cuicui_layout_bevy_ui = &quot;0.10.1&quot;
cuicui_layout = &quot;0.10.1&quot;
cuicui_dsl = &quot;0.10.1&quot;
</code></pre>
<h2 id="using-the-cuicui-crates"><a class="header" href="#using-the-cuicui-crates">Using the cuicui crates</a></h2>
<p>That’s it! You are now using <code>cuicui_layout</code>, congratulations!</p>
<p>Check the next chapters for actual rust code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-menu-using-the-dsl-macro"><a class="header" href="#define-a-menu-using-the-dsl-macro">Define a menu using the <code>dsl!</code> macro</a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>We added previously <code>cuicui_dsl</code>, <code>cuicui_layout</code>, and <code>cuicui_layout_bevy_ui</code>
to our <code>Cargo.toml</code>.</p>
<p>Now let’s write some rust code.</p>
<p>We first import the relevant stuff:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;
use cuicui_dsl::{dsl, EntityCommands};
use cuicui_layout::{dsl_functions::*, LayoutRootCamera};
use cuicui_layout_bevy_ui::UiDsl;</code></pre>
<p>Then, we initialize the bevy <code>app</code>, all standard bevy stuff.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins,
            // Notice that we add the plugin here.
            cuicui_layout_bevy_ui::Plugin,
        ))
        .add_systems(Startup, setup)
        .run();
}</code></pre>
<p>Now we want to spawn the UI. Our UI will be a single menu with 7 buttons, each
with a different text. The buttons and menu all have a background, so we need
a <code>Res&lt;AssetServer&gt;</code>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut cmds: Commands, serv: Res&lt;AssetServer&gt;) {</code></pre>
<p><code>cuicui_layout</code> uses the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.LayoutRootCamera.html"><code>LayoutRootCamera</code></a> component to resize layouts based
on the viewport size. So let’s spawn the camera with it:</p>
<pre><code class="language-rust no_run noplayground">    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));</code></pre>
<p>Now let’s spawn the menu. The methods available on <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a> are listed on <code>docs.rs</code>.</p>
<p>Since <code>UiDsl</code> by default <code>Deref&lt;Target=LayoutDsl&gt;</code>, the methods on <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a> are
also available.</p>
<p>We want:</p>
<ul>
<li>A column menu with the <code>board.png</code> background offset from the left edge of the
screen by 100 pixels.</li>
<li>This column contains a large <code>logo.png</code> and a smaller one, it also contains
7 buttons. We would want some margin between the edges of the screen and
the content of the coulmn, also between the button and the edge of the column.</li>
</ul>
<p>Let’s first start by setting up the column. We define the handles outside of
the <code>dsl!</code> macor, for clarity:</p>
<pre><code class="language-rust no_run noplayground">    let title_card = serv.load(&quot;logo.png&quot;);
    let bg = serv.load(&quot;background.jpg&quot;);
    let board = serv.load(&quot;board.png&quot;);</code></pre>
<p>Then we build the menu. We use the <code>dsl!</code> macro.</p>
<ul>
<li>As first parameter we specify the DSL we want to use, here we use <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a>
from <code>cuicui_layout_bevy_ui</code>, that we imported earlier.</li>
<li>Then, we pass a <code>&amp;mut EntityCommands</code>, which we create by using <code>Commands::spawn_empty</code></li>
<li>Finally, we start the definition of the UI scene.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    dsl! {
        &lt;UiDsl&gt;
        &amp;mut cmds.spawn_empty(),</code></pre>
<p>The first container should have a <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.ScreenRoot.html"><code>ScreenRoot</code></a> component, so that it always has
the same size as the viewport with the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.LayoutRootCamera.html"><code>LayoutRootCamera</code></a> component.</p>
<p>In the <code>LayoutDsl</code>,
you add the screen root component by calling the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.screen_root"><code>LayoutDsl::screen_root</code></a> method.</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start image(&amp;bg)) {</code></pre>
<p>We use <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.row"><code>row</code></a>, because the <em>root</em> node is not the column, it is the “screen”,
the container that will hold the column, and we want to position the column
relative to the left side of the screen.</p>
<p>Speaking of which, we use <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.distrib_start"><code>distrib_start</code></a>, so that the the first object is
placed to the left of the container, the “start” of the distribution zone.</p>
<p>The <code>image(&amp;bg)</code> is the <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html#method.image"><code>UiDsl::image</code></a> method, we pass to it the handle to the
<code>&quot;background.jpg&quot;</code> image.</p>
<p>If you have <a href="https://github.com/nicopap/cuicui_layout/blob/cuicui_layout_bevy_ui-v0.10.0/examples/simple_menu/main.rs">the example code</a> open in your IDE, you should be
able to click on individual methods in the <code>dsl!</code> macro and jump to their source
or see their documentation.</p>
<p>We name the node <code>Root</code>, so that it’s easier to identify it using <code>bevy-inspector-egui</code>.
Let’s see the result:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start image(&amp;bg)) {
    Column(column image(&amp;board))
}</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/distrib_start.jpg" alt="How the menu looks like currently" /></p>
<p>Now let’s add the two logo images to the column.</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start image(&amp;bg)) {
    Column(column image(&amp;board)) {
        TitleCard(image(&amp;title_card))
        TitleCard2(image(&amp;title_card))
    }
}</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/large_column.jpg" alt="The main menu, with the column, but it is way too large and overflows the screen size" /></p>
<p>Ooops. Something bad happened here! Interestingly, <code>cuicui_layout</code> printed an
error message. It noticed that the column overflowed its container. The error is:</p>
<pre><code class="language-text">ERROR bevy_mod_sysfail: Node Root's width is overflowed by its children!
Notes:
- Root's inner size (excluding margins) is 640×360
- There are 1 children of total width 877.5px.
- The largest child is Column
</code></pre>
<p>So far, it doesn’t teach us anything that we didn’t know…</p>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>The best way to diagnose this kind of errors is to set <strong>rules</strong> on the size of
the responsible nodes.</p>
<p><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Rule.html"><code>Rule</code></a>s in <code>cuicui_layout</code> are size constraints on layout nodes. You can set
rules on width and height independently. In the <code>LayoutDsl</code> DSL, you set
constraints through <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.width"><code>width</code></a>, <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.height"><code>height</code></a>, or both at the same time with <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.rules"><code>rules</code></a>.</p>
<p>The size of a container may be:</p>
<ul>
<li><strong>Fixed</strong> (using <code>px(pixels)</code>): it is set to a specific number of pixels.</li>
<li><strong>Child-relative</strong> (using <code>child(ratio)</code>): The container size is equal to
it’s children’s size on that axis TIMES <code>ratio</code> PLUS twice the margin of that axis
(more on margins later).</li>
<li><strong>Parent-relative</strong> (using <code>pct(percent)</code>): it is set to a given percent of
it’s parent inner size<sup class="footnote-reference"><a href="#1">1</a></sup>.</li>
</ul>
<p>So here, we know that <code>Column</code> is too large for <code>Root</code>. So let’s limit its width to 100 pixels.
We also want the column to span the whole height of the screen, so we will set its
height to <code>pct(100)</code>.</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start image(&amp;bg)) {
    Column(column width(px(100)) height(pct(100)) image(&amp;board)) {
        TitleCard(image(&amp;title_card))
        TitleCard2(image(&amp;title_card))
    }
}</code></pre>
<p>Let’s see the result:</p>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/fixed_width_column.jpg" alt="The main menu, with the column, but the images are still too large" /></p>
<p>We now see the whole column, but the logos are still way too large. We get a new
error message:</p>
<pre><code class="language-text">ERROR bevy_mod_sysfail: Node Column's width is overflowed by its children!
Notes:
- Column's inner size (excluding margins) is 100×360
- There are 2 children of total width 585px.
- The largest child is TitleCard2
</code></pre>
<p>In the previous error message, the total width of <code>column</code> was 877.55px, in this,
it is 100px, as we expected, but the children’s width is 585px, which is larger than 100
since last time I checked.</p>
<p>As a hint. Before we specified the size of <code>Column</code>, its rules were the default.
The default rule for containers is <code>child(1.5)</code> (585 * 1.5 = ???).</p>
<h3 id="content-size"><a class="header" href="#content-size">Content size</a></h3>
<p>So our images are why we are overflowing the menu. But why is it so? Well, unlike
container nodes, leaf nodes (nodes without children), if they have an image or text,
get their size from the image’s or text’s size.</p>
<p><code>logo.png</code> just so happens to be a 585px by 173px image. Hmm, 585 seems familiar…</p>
<p>Leaf nodes, like container nodes, can have rule constraints, so let’s limit
the size of the images:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start image(&amp;bg)) {
    Column(column rules(px(100), pct(100)) image(&amp;board)) {
        TitleCard(width(pct(100)) image(&amp;title_card))
        TitleCard2(width(pct(50)) image(&amp;title_card))
    }
}</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/fixed_width_images.jpg" alt="The main menu, with the column, but the images are still too large" /></p>
<p>We see no errors in the terminal. Still something haunts us. We only defined
<em>the width</em>, how comes the height also changed?</p>
<p>It is because, for leaf nodes containing images, if only one axis has a set rule,
the other axis will try to keep aspect ratio with the set rule axis, so as not
to distort the image.</p>
<p>For example here, for <code>TitleCard</code>, we set the width to 100% of its parent, therefore
100 pixels. So given that the size of <code>logo.png</code> is 585x173, if we set its width
to 100, its height will be 29.6 pixels.</p>
<h3 id="margin"><a class="header" href="#margin">Margin</a></h3>
<p>I find the column to be too much to the left, so let’s add margin between the edge of
the container and the first item on the <strong>main axis</strong><sup class="footnote-reference"><a href="#2">2</a></sup> using <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html#method.main_margin"><code>main_margin</code></a>:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
    Column(column rules(px(100), pct(100)) main_margin(10.) image(&amp;board)) {
// ...</code></pre>
<p>Nice, much better. Note that margin is always symetrical. With <code>main_margin(50.)</code>,
we added 50 pixels of margin to the left, but also to the right.</p>
<p>The debug view displays the container margins using a light color. You enable
the debug view by running your app with the <code>--features cuicui_layout/debug</code> flag.</p>
<p>Check this out:</p>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/margin_debug.jpg" alt="The menu with the debug overlay enabled, shows outline of layout nodes" /></p>
<p>In the screenshot, the <code>Root</code> container outlines the whole screen, with lime lines.
Notice the lighter-colored lime lines at the left and right of the screen, those
are the margins of the <code>Root</code> container. You see that the column is directly aligned
with the start of the inside of the <code>Root</code>.</p>
<p>Is this a victory? Only a small battle is won, the war is still ahead.
We have to add our seven buttons.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>For the buttons, we will need text. This is a <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a> method, <a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html#method.text"><code>UiDsl::text</code></a>.</p>
<p>We also want to use <code>button.png</code> as background for our buttons. We loaded it
using <code>let button_bg = serv.load(&quot;button.png&quot;)</code>.</p>
<p>So let’s proceed:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
    Column(column rules(px(100), pct(100)) main_margin(10.) image(&amp;board)) {
        TitleCard(width(pct(100)) image(&amp;title_card))
        TitleCard2(width(pct(50)) image(&amp;title_card))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CONTINUE&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;NEW GAME&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;LOAD GAME&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;SETTINGS&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;ADDITIONAL CONTENT&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CREDITS&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;QUIT GAME&quot;))
    }
}</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/first_buttons.jpg" alt="Main menu with buttons" /></p>
<p>No errors! But very very ugly. Like wow:</p>
<ul>
<li>The column stretches to the whole screen, it makes the layout bottom hevy</li>
<li>“ADDITIONAL CONTENT” height is twice as large as the other buttons, breaking the harmony.</li>
<li>The code itself is ugly, we got a lot of repeating code.</li>
</ul>
<p>Well, on the estethic side, we can’t do much with those assets, but we can set the
fixed width of the column to 150 pixels instead of 100.</p>
<p>For code quality, we use an abstraction. Let’s define a function:</p>
<pre><code class="language-rust no_run noplayground">fn button(cmds: &amp;mut EntityCommands, button_bg: &amp;Handle&lt;Image&gt;, button_text: &amp;'static str) {
    dsl! {
        &lt;UiDsl&gt; cmds,
        Entity(text(button_text) named(button_text) image(button_bg) width(pct(80)))
    }
}</code></pre>
<p>Don’t try to convert it into a closure! Rust’s type system can’t handle closures
that accepts references of different lifetimes, and this will cause a lot of cryptic
error messages.</p>
<p>Now, let’s use the the <code>code</code> statement to call that function:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
    Column(column rules(px(150), pct(100)) main_margin(10.) image(&amp;board)) {
        TitleCard(width(pct(100)) image(&amp;title_card))
        TitleCard2(width(pct(50)) image(&amp;title_card))
        code(let cmds) { button(cmds, &amp;button_bg, &quot;CONTINUE&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;NEW GAME&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;LOAD GAME&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;SETTINGS&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;ADDITIONAL CONTENT&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;CREDITS&quot;) }
        code(let cmds) { button(cmds, &amp;button_bg, &quot;QUIT GAME&quot;) }
    }
}</code></pre>
<p>Not that much better reallly!</p>
<p>But what are we looking at? <code>code</code> statements allow you to <em>inline rust code</em>
within the <code>dsl!</code> macro.</p>
<p>What if instead we defined the button names in a list and use a <code>for</code> loop inside
the <code>code</code> statement?</p>
<pre><code class="language-rust no_run noplayground">    let menu_buttons = [
        &quot;CONTINUE&quot;,
        &quot;NEW GAME&quot;,
        &quot;LOAD GAME&quot;,
        &quot;SETTINGS&quot;,
        &quot;ADDITIONAL CONTENT&quot;,
        &quot;CREDITS&quot;,
        &quot;QUIT GAME&quot;,
    ];</code></pre>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
    Column(column rules(px(150), pct(100)) main_margin(10.) image(&amp;board)) {
        TitleCard(width(pct(100)) image(&amp;title_card))
        TitleCard2(width(pct(50)) image(&amp;title_card))
        code(let cmds) {
            for text in menu_buttons {
                button(cmds, &amp;button_bg, text)
            }
        }
    }
}</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/only_one_button.jpg" alt="Main menu, but only the “QUIT GAME” button exists" /></p>
<p>Well, that’s bad. What happened?</p>
<p>If you have the code open in your text editor, look at the type of <code>cmds</code> in <code>let cmds</code>.</p>
<p>Can you guess why this is happening?</p>
<p>You’ll notice it is an <code>&amp;mut EntityCommands</code>. What we are doing in that <code>for</code> loop
is insert over and over our <code>UiDsl</code> on the same entity. This is why we end up with
a single button.</p>
<p><code>cuicui_dsl</code> passes <code>&amp;mut EntityCommands</code> to <code>code</code> blocks because as a rule, the cuicui DSL
only allows a single entity per statement.</p>
<p>But this doesn’t solve our problem, how would we spawn seven buttons with a
<code>for</code> loop?</p>
<p>The answer is to:</p>
<ol>
<li>Spawn a container for the buttons</li>
<li>Spawn the buttons within that container</li>
</ol>
<pre><code class="language-rust no_run noplayground">                code(let cmds) {
                    dsl! { &lt;UiDsl&gt; cmds,
                        ButtonContainer(column rules(pct(100), pct(60)))
                    };
                    cmds.with_children(|cmds| {
                        for text in menu_buttons {
                            button(&amp;mut cmds.spawn_empty(), &amp;button_bg, text);
                        }
                    });
                }</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/buttons_in_container.jpg" alt="All the buttons are in the menu, but they are distributed unevenly" /></p>
<p>We got back our seven buttons! The code did end up a bit more complex than the
initial repeating code, but if your layout gets complex, this way of abstracting
can get handy.</p>
<p>So to finish it up, we still need to add some “empty space”
at the bottom of the column and some margin for the logo.</p>
<p>The final result:</p>
<pre><code class="language-rust no_run noplayground">    let menu_buttons = [
        &quot;CONTINUE&quot;,
        &quot;NEW GAME&quot;,
        &quot;LOAD GAME&quot;,
        &quot;SETTINGS&quot;,
        &quot;ADDITIONAL CONTENT&quot;,
        &quot;CREDITS&quot;,
        &quot;QUIT GAME&quot;,
    ];
    let button_bg = serv.load(&quot;button.png&quot;);
    let title_card = serv.load(&quot;logo.png&quot;);
    let bg = serv.load(&quot;background.jpg&quot;);
    let board = serv.load(&quot;board.png&quot;);

    dsl! {
        &lt;UiDsl&gt;
        &amp;mut cmds.spawn_empty(),
        Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
            Column(image(&amp;board) rules(px(150), pct(100)) main_margin(10.) column) {
                TitleCard(width(pct(100)) image(&amp;title_card))
                TitleCard2(width(pct(50)) ui(title_card))
                code(let cmds) {
                    dsl! { &lt;UiDsl&gt; cmds,
                        ButtonContainer(column rules(pct(100), pct(60)))
                    };
                    cmds.with_children(|cmds| {
                        for text in menu_buttons {
                            button(&amp;mut cmds.spawn_empty(), &amp;button_bg, text);
                        }
                    });
                }
                BottomSpacer(height(pct(15)))
            }
        }
    };</code></pre>
<p><img src="../examples/simple_menu/../../simple_menu_gallery/final_result.jpg" alt="Main menu with balanced button distribution" /></p>
<p>Woohoo! Time to treat yourself.</p>
<p>Next, we will do this using <code>cuicui_chirp</code> and the chirp language.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The <strong>main axis</strong> is the axis of direction of the container. For a <code>row</code>
container, the main axis is the <code>x</code> axis. For a <code>column</code> container, it is the
<code>y</code> axis. The <strong>cross axis</strong> is the axis perpendicular to the corss axis (so
<code>y</code> for <code>row</code> containers and <code>x</code> for <code>column</code> containers)</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The “Inner size” is the size of a node deduced its margins on a given axis.
It’s the effective size children can occupy, so we use that for percentage.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-menu-using-a-chirp-file"><a class="header" href="#define-a-menu-using-a-chirp-file">Define a menu using a chirp file</a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>We will now use <code>cuicui_chirp</code> to define the UI. To do so, we need to add it
as a dependency first:</p>
<pre><code class="language-toml">[dependencies]
# previous dependencies
# ...
# New dependency:
cuicui_chirp = &quot;0.10.1&quot;
</code></pre>
<p>The app setup requires adding <code>cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;()</code>,
we also setup hot reloading by setting the asset plugin.</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins((
            DefaultPlugins.set({
                let delay = Duration::from_millis(200);
                let watch_for_changes = bevy::asset::ChangeWatcher::with_delay(delay);
                AssetPlugin { asset_folder, watch_for_changes }
            }),
            cuicui_layout_bevy_ui::Plugin,
            // You still need to add manually the asset loader for UiDsl!
            cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;(),
        ))
        .add_systems(Startup, setup)
        .run();</code></pre>
<p>The <code>setup</code> system, where we previously spawned the whole scene, is now
completely trivial, we just spawn a single entity with a <code>ChirpBundle</code>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut cmds: Commands, serv: Res&lt;AssetServer&gt;) {
    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));

    cmds.spawn(ChirpBundle::new(serv.load(&quot;chirp_menu.chirp&quot;)));
}</code></pre>
<p><code>chirp_menu.chirp</code> is located the <code>assets/</code> folder.</p>
<p>This chapter assumes you’ve read <a href="../examples/chirp_menu/../simple_menu">the previous chapter</a>. We will
use it as a base for this.</p>
<p>So where to start? Well, let’s copy/past the code from the simple menu example
into <code>chirp_menu.chirp</code> and see what happens:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50.) image(&amp;bg)) {
    Column(column rules(px(100), pct(100)) main_margin(10.) image(&amp;board)) {
        TitleCard(width(pct(100)) image(&amp;title_card))
        TitleCard2(width(pct(50)) image(&amp;title_card))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CONTINUE&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;NEW GAME&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;LOAD GAME&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;SETTINGS&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;ADDITIONAL CONTENT&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CREDITS&quot;))
        Entity(image(&amp;button_bg) width(pct(80)) text(&quot;QUIT GAME&quot;))
    }
}</code></pre>
<p>Of course this doesn’t work! But here the error format is different. The game
compiles, <code>cuicui_chirp</code> tries to load the file and displays errors it encountered
instead of spawning a scene:</p>
<pre><code class="language-text">Error:   × Failed to load 'Handle&lt;bevy_render::texture::image::Image&gt;' from file '&amp;button_bg':
  │ No such file or directory (os error 2)
    ╭─[chirp_menu.chirp:10:1]
 10 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;ADDITIONAL CONTENT&quot;))
 11 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CREDITS&quot;))
 12 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;QUIT GAME&quot;))
    ·                      ──────────
 13 │     }
 14 │ }
    ╰────
  help: The error comes from the ParseDsl implementation.
Error:   × Rule format was not recognized: 'pct(80)', rules end with '%', '*' or 'px'.
  │ Examples: '53%', '0.35*' and '1024px'
    ╭─[chirp_menu.chirp:10:1]
 10 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;ADDITIONAL CONTENT&quot;))
 11 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;CREDITS&quot;))
 12 │         Entity(image(&amp;button_bg) width(pct(80)) text(&quot;QUIT GAME&quot;))
    ·                                        ───────
 13 │     }
 14 │ }
    ╰────
  help: The error comes from the ParseDsl implementation.
</code></pre>
<p>The part of the error message we are the most interested in is the bit of text after <code>Error</code>:</p>
<blockquote>
<p>× Failed to load ‘Handle&lt;bevy_render::texture::image::Image&gt;’ from file ‘&amp;button_bg’:<br>
│ No such file or directory (os error 2)</p>
</blockquote>
<p>and</p>
<blockquote>
<p>× Rule format was not recognized: ‘pct(80)’, rules end with ‘%’, ‘*’ or ‘px’.<br>
│ Examples: ‘53%’, ‘0.35*’ and ‘1024px’</p>
</blockquote>
<p>Don’t close the window! Chirp files are hot-reloadable, you can edit the file
and see the effect live.</p>
<p>We have two kind of errors here:</p>
<ol>
<li>Argument to the <code>image</code> method.</li>
<li>Argument to <code>width</code> and <code>rule</code>.</li>
</ol>
<p>For (1), <strong>methods that accept a <code>Handle&lt;T&gt;</code> in rust accept a string argument
in chirp files</strong>. For (2), chirp files use the
<code>FromStr</code> implementation on <code>Rule</code> to parse them, again, as the error message
states.</p>
<p>So let’s replace the variables from the DSL example with the file path and
change the syntax on rules:</p>
<pre><code class="language-rust no_run noplayground">Root(screen_root row distrib_start main_margin(50) image(&quot;background.jpg&quot;)) {
    Column(column rules(100px, 100pct) main_margin(10) image(&quot;board.png&quot;)) {
        TitleCard(width(100pct) image(&quot;logo.png&quot;))
        TitleCard2(width(50pct) image(&quot;logo.png&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;CONTINUE&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;NEW GAME&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;LOAD GAME&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;SETTINGS&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;ADDITIONAL CONTENT&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;CREDITS&quot;))
        Entity(image(&quot;button.png&quot;) width(80%) text(&quot;QUIT GAME&quot;))
    }
}</code></pre>
<p>Save the file and …</p>
<p>New set of errors, but not as many.
We forgot to convert <code>pct</code> to <code>%</code> in some places. Let’s fix this and save again.</p>
<p><img src="../examples/chirp_menu/../../chirp_menu_gallery/first_attempt.jpg" alt="The scene from simple menu, now loaded" /></p>
<details><summary><b>Rules syntax by context</b></summary>
<p>So how to write <code>cuicui_layout</code> rules? Here is a table:</p>
<p>Note that <code>pct</code>, <code>child</code> and <code>px</code> are <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/index.html#functions"><strong>rust functions</strong></a>
and must be imported.</p>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html"><code>Rule</code></a></th><th>in <code>dsl!</code></th><th>in chirp</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html#variant.Children"><code>Children</code></a></td><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/fn.child.html"><code>child</code></a></td><td><code>2*</code></td></tr>
<tr><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html#variant.Parent"><code>Parent</code></a></td><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/fn.pct.html"><code>pct</code></a></td><td><code>95%</code></td></tr>
<tr><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html#variant.Fixed"><code>Fixed</code></a></td><td><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/fn.px.html"><code>px</code></a></td><td><code>120px</code></td></tr>
</tbody></table>
</div></details>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<p>This is already good. And it was much faster than before! Didn’t even need to
close and re-open the game once!</p>
<p>But, as before, we’d like to make this shorter. To do this, we’ll extract the button
entity into a <strong>template definition</strong>. In chirp, you define templates at the
beginning of the file with the <code>fn</code> keyword, and you use them like you would use
a rust macro:</p>
<pre><code class="language-rust no_run noplayground">// Define a template
fn button() {
    Button(image(&quot;button.png&quot;) width(80%) text(&quot;Button&quot;))
}
Root(screen_root row distrib_start main_margin(50) image(&quot;background.jpg&quot;)) {
    Column(column rules(150px, 100%) main_margin(10) image(&quot;board.png&quot;)) {
        TitleCard(width(100%) image(&quot;logo.png&quot;))
        TitleCard2(width(50%) image(&quot;logo.png&quot;))
        // Call it like a rust macro
        button!()
        button!()
        button!()
        button!()
        button!()
        button!()
        button!()
    }
}</code></pre>
<p>Again, all you need to do is hit the save shortcut in your text editor, and
the changes show up directly on screen. (Or errors in the terminal, if any)</p>
<p><img src="../examples/chirp_menu/../../chirp_menu_gallery/button_button.jpg" alt="All buttons now have the “Button” text" /></p>
<h3 id="template-arguments"><a class="header" href="#template-arguments">Template arguments</a></h3>
<p>Well, we still want to have different names per button. Miracle, templates support
<strong>parameters</strong>. They are like argument to rust functions:</p>
<pre><code class="language-rust no_run noplayground">// button_text is a parameter
fn button(button_text) {
    //     'named' allows us to set the entity name dynamically
    //     vvvvv   We can use the template parameter as argument to methods
    //     vvvvv vvvvvvvvvvv                                      vvvvvvvvvvv
    Entity(named(button_text) image(&quot;button.png&quot;) width(80%) text(button_text))
}</code></pre>
<p>And when calling the template, we pass an argument:</p>
<pre><code class="language-rust no_run noplayground">        TitleCard(width(100%) image(&quot;logo.png&quot;))
        TitleCard2(width(50%) image(&quot;logo.png&quot;))
        // just pass the button name as argument
        button!(&quot;CONTINUE&quot;)
        button!(&quot;NEW GAME&quot;)
        button!(&quot;LOAD GAME&quot;)
        button!(&quot;SETTINGS&quot;)
        button!(&quot;ADDITIONAL CONTENT&quot;)
        button!(&quot;CREDITS&quot;)
        button!(&quot;QUIT GAME&quot;)</code></pre>
<h4 id="template-parameter-substitution-rules"><a class="header" href="#template-parameter-substitution-rules">Template parameter substitution rules</a></h4>
<p>Currently, it is not possible to use template parameters everywhere.
See <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/index.html#parameter-substitution">limitations</a>.</p>
<h3 id="template-extras"><a class="header" href="#template-extras">Template extras</a></h3>
<p>Now we want each button to have a different color. There are seven of them, like
the seven dwarfes, <del>the seven fingers of the hand</del>, and seven colors of the rainbow!</p>
<p>We could add a second parameter to our template, but instead, we’ll use a method extra:</p>
<pre><code class="language-rust no_run noplayground">        button!(&quot;CONTINUE&quot;)(bg(red))
        button!(&quot;NEW GAME&quot;)(bg(orange))
        button!(&quot;LOAD GAME&quot;)(bg(yellow))
        button!(&quot;SETTINGS&quot;)(bg(green))
        button!(&quot;ADDITIONAL CONTENT&quot;)(bg(cyan))
        button!(&quot;CREDITS&quot;)(bg(blue))
        button!(&quot;QUIT GAME&quot;)(bg(violet))</code></pre>
<p><img src="../examples/chirp_menu/../../chirp_menu_gallery/rainbow.jpg" alt="Now the buttons’s outline are varycolored" /></p>
<p>A bit ugly. We should make <code>&quot;button.png&quot;</code> white so that it mixes with the rainbow
colors correctly.</p>
<p>In the chirp file, what happens here is that we are adding the <code>bg(color)</code> method
to the entity spawned by <code>button!</code>. In effect <code>button!(&quot;CREDITS&quot;)(bg(blue))</code>,
if we expand the template, becomes:</p>
<pre><code class="language-rust no_run noplayground">//                                 bg(blue) method is added to the end vvvvvvvv
Entity(named(&quot;CREDITS&quot;) image(&quot;button.png&quot;) width(80%) text(&quot;CREDITS&quot;) bg(blue))</code></pre>
<p>Template extras also work with children nodes, within <code>{}</code>.</p>
<p>And that’s pretty much it when it comes to <code>cuicui_chirp</code>. Next, we will
add a bit of interactivity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scaling-up-with-a-custom-dsl"><a class="header" href="#scaling-up-with-a-custom-dsl">Scaling up with a custom DSL</a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p><a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/"><code>cuicui_dsl</code></a> and <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/"><code>cuicui_chirp</code></a> are parametrized over the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/trait.DslBundle.html"><code>DslBundle</code></a> and
<a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a> traits respectively.</p>
<p>You can directly use one of the DSLs exported by an external crate such as
<a href="https://docs.rs/cuicui_layout_bevy_ui/0.10.1/cuicui_layout_bevy_ui/dsl/struct.UiDsl.html"><code>UiDsl</code></a>, <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a>, <a href="https://docs.rs/bevy-ui-navigation/0.32.0/bevy_ui_navigation/index.html"><code>NavigationDsl</code></a> or <a href="https://docs.rs/cuicui_layout_bevy_sprite/0.10.1/cuicui_layout_bevy_sprite/struct.SpriteDsl.html"><code>SpriteDsl</code></a>, but we recommend
that you define your own DSL on top of them.</p>
<p>This is how <a href="https://github.com/nicopap/cuicui_layout/tree/main/examples/chirpunk">the chirpunk example</a> works. We re-use pre-existing DSLs, but add
our own layer on top, to create a unique vocabulary that applies to the specific
game we build.</p>
<p>So let’s make a game.</p>
<h2 id="better-factorio"><a class="header" href="#better-factorio">Better Factorio</a></h2>
<p>What better genre than factory-building to illustrate a game UI library?
Let’s mix in some grand strategy for good measure. We’ll make
Factorio×CrusaderKings fusion.</p>
<p>Our goal is to make:</p>
<ul>
<li>A menu with several tabs, tabs are:</li>
<li>A “game” menu with buttons that represent game menu buttons, clicking on them prints a message</li>
<li>A “production” menu (with static <code>png</code> as graph for now)</li>
<li>A “diplomacy” menu where we can start and end wars, marry someone, launch missiles</li>
</ul>
<p>We will be able to swap menu by clicking buttons, and most game-specific actions
will result in a message being logged into the terminal.</p>
<p>For more complex interaction patterns, read <a href="../examples/custom_dsl/../../reactivity.html">the next chapter</a>.</p>
<h2 id="a-menu-with-tabs"><a class="header" href="#a-menu-with-tabs">A menu with tabs</a></h2>
<p>So let’s make a menu.</p>
<p>First, we write the whole menu. To pretend it is a game menu, we draw a
background and then have the menu occupy a subset of the screen. We do that
by setting a 25 pixels margin on the <code>Root</code> entity.</p>
<p>The menu with tabs is a column menu, the first row is the tab line, the second
the content:</p>
<pre><code class="language-rust no_run noplayground">Root(row screen_root margins(25, 25) image(&quot;background.jpg&quot;)) {
    Menus(column rules(100%, 100%)) {</code></pre>
<p>Then, we fill up the rest.</p>
<p>The tab line:</p>
<pre><code class="language-rust no_run noplayground">        Tabs(row rules(100%, 12.5%) distrib_start) {
            tab!(&quot;Game Menu&quot;, 0, burlywood)
            tab!(&quot;Production Menu&quot;, 1, #6b4d22)
            tab!(&quot;Diplomacy Menu&quot;, 2, #6b4d22)
        }</code></pre>
<p>(more on the <code>tab!</code> template later)</p>
<pre><code class="language-rust no_run noplayground">        Menu(layout(&quot;&gt;oCaC&quot;) rules(100%, 87.5%) marked(Tabs) bg(burlywood)) {
            game_menu!()
            production_menu!()(hidden)
            diplomacy_menu!()(hidden)
        }</code></pre>
<p>The content uses the overlapping layout distribution mode with <code>layout(&quot;&gt;oCaC&quot;)</code>
(the <code>o</code> is the important bit, it stands for “overlapping”). This allows
each child of <code>Menu</code> to occupy the same space.</p>
<p>We now just have <code>tab</code>, <code>game_menu</code>, <code>production_menu</code>, and <code>diplomacy_menu</code> to
define. (more on those <code>(hidden)</code> later)</p>
<p><img src="../examples/custom_dsl/../../custom_dsl_gallery/all_overlapping.png" alt="Several nodes on the same space" /></p>
<h2 id="hide-the-menus"><a class="header" href="#hide-the-menus">Hide the menus</a></h2>
<p>We used <em>template extras</em> here to mark two of the <code>Menu</code> children as “hidden”.</p>
<pre><code class="language-rust no_run noplayground">game_menu!()
production_menu!()(hidden)
diplomacy_menu!()(hidden)</code></pre>
<p>Indeed, we don’t want all three menus to be visible at the same time. To this
end, we spawn the production and diplomacy menus with the <code>Visibility</code> component
set to <code>Hidden</code>.</p>
<p>But here is the hang up! Neither <code>LayoutDsl</code> or <code>UiDsl</code> have a <code>hidden</code> method,
how are we to set the <code>Visibility</code> component?</p>
<p>Answer: <strong>We write our own DSL.</strong></p>
<p>Let’s start by creating a new module:</p>
<pre><code class="language-rust no_run noplayground">mod dsl;</code></pre>
<p>Then define a <code>BetterFactorioDsl</code>:</p>
<pre><code class="language-rust no_run noplayground">// `DslBundle` requires `Default`
#[derive(Default)]
pub struct BetterFactorioDsl {
    inner: UiDsl,
    is_hidden: bool,
}</code></pre>
<p>Let’s add the chirp loader for <code>BetterFactorioDsl</code> in our <code>add_plugins</code>:</p>
<pre><code class="language-rust no_run noplayground">            cuicui_chirp::loader::Plugin::new::&lt;BetterFactorioDsl&gt;(),</code></pre>
<p>We need to implement <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a> and <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/trait.DslBundle.html"><code>DslBundle</code></a> on <code>BetterFactorioDsl</code>
for this to compile.
The <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a> macro is how we implement <code>ParseDsl</code>.
We use the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/fn.delegate.html"><code>delegate</code></a> meta-attribute, so that we can re-use the <code>UiDsl</code> and
<code>LayoutDsl</code> methods in our chirp file:</p>
<pre><code class="language-rust no_run noplayground">#[parse_dsl_impl(delegate = inner)]
impl BetterFactorioDsl {}

impl DslBundle for BetterFactorioDsl {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        self.inner.insert(cmds)
    }
}</code></pre>
<p>It compiles now, but we are missing the <code>hidden</code> method:</p>
<pre><code>Error:   × No 'hidden' method
    ╭─[better_factorio/menu.chirp:65:1]
 65 │             game_menu!()
 66 │             production_menu!()(hidden)
 67 │             diplomacy_menu!()(hidden)
    ·                               ^^^^^^
 68 │         }
    ╰────
  help: custom_dsl::dsl::BetterFactorioDsl doesn't contain a method with this name.
</code></pre>
<p>Let’s add it then! We already have a <code>is_hidden</code> field, we just have to
define a <code>hidden</code> method to set it:</p>
<pre><code class="language-rust no_run noplayground">impl BetterFactorioDsl {
    fn hidden(&amp;mut self) {
        self.is_hidden = true;
    }</code></pre>
<p>Now we can read the <code>is_hidden</code> field in the <strong><code>DslBundle::insert</code></strong> implementation:</p>
<pre><code class="language-rust no_run noplayground">        let id = self.inner.insert(cmds);
        if self.is_hidden {
            cmds.insert(Visibility::Hidden);
        }
        id</code></pre>
<p>Make sure to add it <em>after</em> the <code>inner.insert(cmds)</code>. <code>Visibility</code> is part of the
<code>NodeBundle</code> that <code>UiDsl</code> adds to the entity. Adding it <em>after</em> the <code>inner</code> ensures
that we overwrite the <code>Visibility</code> component with the wanted value.</p>
<h2 id="game-menu--interaction"><a class="header" href="#game-menu--interaction">Game menu &amp; interaction</a></h2>
<p>Ok, so I included the game menu in all those screenshots, but didn’t define it
yet. Sorry for the confusion.</p>
<p>The game menu was a template call, <code>game_menu!()</code>. Then, let’s define it.</p>
<pre><code class="language-rust no_run noplayground">fn game_menu() {
    GameMenu(column rules(100%, 100%)) {
        Entity(height(0%))
        print_button!(&quot;Resume game&quot;)
        print_button!(&quot;Mute/Unmute&quot;)
        print_button!(&quot;Save game&quot;)
        print_button!(&quot;Quit&quot;)
        Entity(height(0%))
    }
}</code></pre>
<p><code>print_button!</code> is yet another template. It stands for a button we can click,
when clicking it, a message is displayed in the console.</p>
<pre><code class="language-rust no_run noplayground">fn print_button(button_text) {
    Entity(print_text(button_text) highlight row rules(1.1*, 2*) named(button_text) bg(brown)) {
        ButtonText(text(button_text))
    }
}</code></pre>
<p>Notice that we called the <code>print_text(button_text)</code> and <code>highlight</code> methods in
<code>print_button!</code>.</p>
<ul>
<li><code>highlight</code> should add a component that changes the color of the button when
it’s being hovered</li>
<li><code>print_text</code> does print in the console the button text content.</li>
</ul>
<p>Let’s add them to our <code>BetterFactorioDsl</code>.</p>
<h3 id="using-bevy_mod_picking"><a class="header" href="#using-bevy_mod_picking">Using <code>bevy_mod_picking</code></a></h3>
<p>We will use the <a href="https://crates.io/crates/bevy_mod_picking"><code>bevy_mod_picking</code></a> components for this.</p>
<p>We should use the <a href="https://docs.rs/bevy_mod_picking/0.15.0/bevy_mod_picking/prelude/struct.On.html"><code>On</code></a> component from <code>bevy_mod_picking</code>. One issue with <code>On</code>
is that it is not <a href="https://docs.rs/bevy/0.11/bevy/reflect/trait.Reflect.html"><code>Reflect</code></a>, therefore, we cannot use it in our chirp file;
<code>cuicui_chirp</code> creates a scene then adds it to the bevy world, and this requires
all components from the scene to be <code>Reflect</code>.</p>
<blockquote>
<p><code>cuicui_dsl</code> doesn’t have this issue.</p>
</blockquote>
<p>We can get around this limitation by creating a “mirror” component. Mirror
components are <code>Reflect</code> proxies that are synchronized with actual components.</p>
<p>We already define a <code>MirrorPlugin</code> in the <a href="https://github.com/nicopap/cuicui_layout/tree/main/examples/cuicui_examples"><code>cuicui_examples</code></a> shared code.</p>
<blockquote>
<p>I plan on extracting this into a standalone crate, <code>cuicui_mirror</code>.</p>
</blockquote>
<p>All we have left to do is to define a mirror component,
implement <code>From&lt;&amp;ReflectOnClick&gt;</code> for <code>On&lt;Pointer&lt;Click&gt;&gt;</code>, and add <code>MirrorPlugin</code>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::{info, Component, EventWriter, Reflect, ReflectComponent};
use bevy_mod_picking::prelude::{Click, On, Pointer};

use crate::dsl::{SwitchGraph, SwitchTab};

#[derive(Reflect, Default, Component)]
#[reflect(Component)]
pub enum ReflectOnClick {
    LogInfo(String),
    EmitSwitchTab(u8),
    EmitSwitchGraph(u8),
    #[default]
    Invalid,
}
type OnClick = On&lt;Pointer&lt;Click&gt;&gt;;

impl&lt;'a&gt; From&lt;&amp;'a ReflectOnClick&gt; for OnClick {
    fn from(value: &amp;'a ReflectOnClick) -&gt; Self {
        match value {
            ReflectOnClick::LogInfo(text) =&gt; {
                let text = text.clone();
                OnClick::run(move || info!(&quot;{text}&quot;))
            }
            &amp;ReflectOnClick::EmitSwitchTab(index) =&gt; {
                OnClick::run(move |mut ev: EventWriter&lt;_&gt;| ev.send(SwitchTab(index)))
            }
            &amp;ReflectOnClick::EmitSwitchGraph(index) =&gt; {
                OnClick::run(move |mut ev: EventWriter&lt;_&gt;| ev.send(SwitchGraph(index)))
            }
            ReflectOnClick::Invalid =&gt; unreachable!(&quot;Should never spawn an invalid ReflectOnClick&quot;),
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">            bevy_mod_picking::DefaultPickingPlugins,
            cuicui_examples::MirrorPlugin::&lt;OnClick, ReflectOnClick&gt;::new_from(),</code></pre>
<p>Now let’s amend <code>BetterFactorioDsl</code> to add the <code>highlight</code> and <code>print_text</code> methods:</p>
<pre><code class="language-diff no_run noplayground">#[derive(Default)]
pub struct BetterFactorioDsl {
    inner: UiDsl,
    is_hidden: bool,
+   is_highlight: bool,
+   text_to_print: Option&lt;Box&lt;str&gt;&gt;,
}
</code></pre>
<p>In the <code>#[parse_dsl_impl] impl BetterFactorioDsl</code> block:</p>
<pre><code class="language-rust no_run noplayground">    fn print_text(&amp;mut self, text: &amp;str) {
        self.text_to_print = Some(text.into());
    }
    fn highlight(&amp;mut self) {
        self.is_highlight = true;
    }</code></pre>
<p>In <code>DslBundle::insert for BetterFactorioDsl</code>:</p>
<pre><code class="language-rust no_run noplayground">        if let Some(text) = self.text_to_print.take() {
            cmds.insert(ReflectOnClick::LogInfo(text.into()));
        }
        if self.is_highlight {
            cmds.insert(Highlight::new(Color::BEIGE));
        }</code></pre>
<p>I’ll skip over <code>Highlight</code> here, you can <a href="https://github.com/nicopap/cuicui_layout/blob/main/examples/cuicui_examples/src/highlight.rs">see the implementation for yourself</a>.
Similarly to <code>ReflectOnClick</code>, we use <code>bevy_mod_picking</code> to react to events, but
define it as a standalone <code>Reflect</code> component to be able to use it in a scene.</p>
<p><img src="../examples/custom_dsl/../../custom_dsl_gallery/hover.gif" alt="A mouse cursor moving over buttons that change color when they are hovered" /></p>
<p>(not shown: the logs in the terminal)</p>
<h2 id="the-tab-line"><a class="header" href="#the-tab-line">The tab line</a></h2>
<p>Now that only a single menu shows up at a time, we should have the ability to
switch between them.</p>
<p>We should be able to click on a tab to swap between menu.</p>
<p>Let’s define our <code>tab!</code> template.</p>
<ul>
<li>We’ll use a darker tone color for unselected tabs, <code>#6b4d22</code>.</li>
<li>We’ll give some space between each tab, to reproduce real world tabs
(<a href="https://en.wikipedia.org/wiki/Skeuomorph">skeuomorphic design</a> 🤓).</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn tab(menu_name) {
    Entity(row rules(1.1*, 100%) named(menu_name)) {
        TabSurface(highlight row rules(1.1*, 100%) bg(#6b4d22)) {
            TabText(text(menu_name))
        }
    }
}
// ...
Tabs(row rules(100%, 12.5%) distrib_start) {
    tab!(&quot;Game Menu&quot;)
    tab!(&quot;Production Menu&quot;)
    tab!(&quot;Diplomacy Menu&quot;)
}</code></pre>
<p><img src="../examples/custom_dsl/../../custom_dsl_gallery/all_deselected_tabs.png" alt="Our menu with the tabs, but all deselected" /></p>
<p>It’s nice and all, but we need some interactivity. We also need the selected tab
to have the same color as the game menu background.</p>
<p>We can’t use <em>template extras</em> in this case, because the root node of the <code>tab</code>
template is transparent, we need to pass the color as an additional argument</p>
<pre><code class="language-diff">-fn tab(menu_name) {
+fn tab(menu_name, initial_color) {
    Entity(row rules(1.1*, 100%) named(menu_name)) {
-       TabSurface(highlight row rules(1.1*, 100%) bg(#6b4d22)) {
+       TabSurface(highlight row rules(1.1*, 100%) bg(initial_color)) {
            TabText(text(menu_name))
        }
Tabs(row rules(100%, 12.5%) distrib_start) {
-   tab!(&quot;Game Menu&quot;)
-   tab!(&quot;Production Menu&quot;)
-   tab!(&quot;Diplomacy Menu&quot;)
+   tab!(&quot;Game Menu&quot;, burlywood)
+   tab!(&quot;Production Menu&quot;, #6b4d22)
+   tab!(&quot;Diplomacy Menu&quot;, #6b4d22)
</code></pre>
<h3 id="switching-between-tabs"><a class="header" href="#switching-between-tabs">Switching between tabs</a></h3>
<p>Unlike the <code>print_text</code> buttons, here, we need to change which menu is visible
when the tab is pressed. So let’s create a new method: <code>switch_tab</code> and add it
to our template:</p>
<pre><code class="language-diff">    Entity(row rules(1.1*, 100%) named(menu_name)) {
-       TabSurface(highlight row rules(1.1*, 100%) bg(#6b4d22)) {
+       TabSurface(highlight switch_tab(menu_index) row rules(1.1*, 100%) bg(initial_color)) {
            TabText(text(menu_name))
        }
</code></pre>
<p>Similarly to <a href="https://github.com/nicopap/cuicui_layout/blob/main/examples/cuicui_examples/src/highlight.rs"><code>Highlight</code></a>, I won’t expand on <code>switch_tab</code>. The
idea is to:</p>
<ol>
<li>Have a <code>TabButton(u8)</code> component. Whenever an entity with this component is
clicked, send a <code>SwitchTab</code> event with the <code>u8</code>.</li>
<li>Mark the parent of all the three menus with a component, <code>Tabs</code>.</li>
<li>Whenever we receive a <code>SwitchTab(u8)</code> component, query for the <code>Tabs</code> entity and
its children, set <code>Visibility</code> of all the children but the <code>u8</code> to <code>Visibility::Hidden</code>.</li>
</ol>
<pre><code class="language-rust no_run noplayground">    use Visibility::{Hidden, Inherited};

    for req in tab_requests.iter() {
        let Ok(menu_children) = tab_menu.get_single() else {
            continue;
        };
        let mut i = 0;
        let mut iter = vis.iter_many_mut(menu_children);
        while let Some(mut vis) = iter.fetch_next() {
            *vis = if i == req.index() { Inherited } else { Hidden };
            i += 1;
        }
    }</code></pre>
<p><a href="https://github.com/nicopap/cuicui_layout/blob/main/examples/cuicui_examples/src/switch.rs">See the implementation for details</a>.</p>
<p>We need to use <code>bevy_mod_picking</code> for this as well, and this requires using a
mirror component. Conveniently, we already did it in <a href="../examples/custom_dsl/index.html#using-bevy_mod_picking">a previous section</a>.</p>
<pre><code class="language-diff no_run noplayground">#[derive(Default)]
pub struct BetterFactorioDsl {
    inner: UiDsl,
    is_hidden: bool,
    is_highlight: bool,
    text_to_print: Option&lt;Box&lt;str&gt;&gt;,
+   switch_tab: Option&lt;u8&gt;,
}
</code></pre>
<p>In the <code>#[parse_dsl_impl] impl BetterFactorioDsl</code> block:</p>
<pre><code class="language-rust no_run noplayground">    fn switch_tab(&amp;mut self, index: u8) {
        self.switch_tab = Some(index);
    }</code></pre>
<p>In <code>DslBundle::insert for BetterFactorioDsl</code>:</p>
<pre><code class="language-rust no_run noplayground">        if let Some(index) = self.switch_tab {
            cmds.insert((ReflectOnClick::EmitSwitchTab(index), TabButton(index)));
        }</code></pre>
<p>Finally, we need to pass the menu index as parameter to the template:</p>
<pre><code class="language-rust no_run noplayground">fn tab(menu_name, menu_index, color) {
    Entity(row rules(1.1*, 100%) named(menu_name)) {
        TabSurface(highlight switch_tab(menu_index) row rules(1.1*, 100%) bg(color)) {
            TabText(text(menu_name))
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">        Tabs(row rules(100%, 12.5%) distrib_start) {
            tab!(&quot;Game Menu&quot;, 0, burlywood)
            tab!(&quot;Production Menu&quot;, 1, #6b4d22)
            tab!(&quot;Diplomacy Menu&quot;, 2, #6b4d22)
        }</code></pre>
<p><img src="../examples/custom_dsl/../../custom_dsl_gallery/switch_tab.gif" alt="Navigating between menus with tabs" /></p>
<h2 id="diplomacy-and-production"><a class="header" href="#diplomacy-and-production">Diplomacy and Production</a></h2>
<p>The diplomacy menu is very similar to the game menu, I won’t go over it, just
get a look at the code:</p>
<pre><code class="language-rust no_run noplayground">fn diplomacy_menu() {
    DiplomacyMenu(column rules(100%, 90%)) {
        print_button!(&quot;Start war&quot;)
        print_button!(&quot;End war&quot;)
        print_button!(&quot;Marry Someone&quot;)
        print_button!(&quot;Launch Missiles&quot;)
    }
}</code></pre>
<p>The production menu is more interesting. Similarly to the root menu, we want
several panels (production types: electricity, water, pollution)
we can switch between, and buttons to select the panel.</p>
<p>We will use the same <a href="https://github.com/nicopap/cuicui_layout/blob/main/examples/cuicui_examples/src/switch.rs">switch</a> implementation that we used for tabs.
This time, we will name our method <code>switch_graph</code>. I won’t go over the rust
implementation, as it’s pretty much a copy/paste of the tabs switching code.</p>
<pre><code class="language-rust no_run noplayground">fn production_button(button_text) {
    Entity(layout(&quot;&gt;dSaC&quot;) named(button_text) rules(100%, 1.5*) bg(#6b4d22) highlight) {
        Entity(text(button_text))
    }
}
fn production_menu() {
    ProductionMenu(row rules(100%, 90%) main_margin(30)) {
        TypesColumn(layout(&quot;vdSaS&quot;) rules(19%, 100%)) {
            production_button!(Electricity)(switch_graph(0) bg(burlywood))
            production_button!(Water usage)(switch_graph(1))
            production_button!(Polution)(switch_graph(2))
        }
        Entity(rules(0.5%, 90%) bg(brown))
        TypesGraph(layout(&quot;&gt;oCaC&quot;) rules(80%, 100%) marked(Graphs)) {
            Electricity(image(&quot;better_factorio/elect_graph.png&quot;) width(100%))
            WaterUsage(image(&quot;better_factorio/water_graph.png&quot;) hidden width(100%))
            Polution(image(&quot;better_factorio/pollution_graph.png&quot;) hidden height(100%))
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-examples"><a class="header" href="#running-examples">Running examples</a></h2>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>Use the <code>cargo run --bin</code> command to list possible examples, and run them.</p>
<p>We do this because it allows us to have different dependencies between examples.</p>
<h3 id="specific-example-docs"><a class="header" href="#specific-example-docs">Specific example docs</a></h3>
<h4 id="hello_world"><a class="header" href="#hello_world"><code>hello_world</code></a></h4>
<p>The most minimal code to show usage of <code>cuicui_layout</code> using <code>cuicui_dsl</code></p>
<h4 id="simple_menu"><a class="header" href="#simple_menu"><code>simple_menu</code></a></h4>
<p>A single menu made using <code>cuicui_dsl</code>.</p>
<h4 id="chirp_menu"><a class="header" href="#chirp_menu"><code>chirp_menu</code></a></h4>
<p>A single menu supporting hot reloading made using <code>cuicui_chirp</code>.</p>
<h4 id="cuicui_examples"><a class="header" href="#cuicui_examples"><code>cuicui_examples</code></a></h4>
<p>Library of plugins useful for the more advanced examples.</p>
<ul>
<li><code>SwitchPlugin</code>: An event-driven toggle between N children of an entity</li>
<li><code>MirrorPlugin</code>: A way to sync <code>Reflect</code> components with non-<code>Reflect</code> 3rd party components.</li>
<li><code>HighlightPlugin</code>: <code>bevy_mod_picking</code>-based hover highlight that tries to
be smart about color changes.</li>
</ul>
<h4 id="custom_dsl"><a class="header" href="#custom_dsl"><code>custom_dsl</code></a></h4>
<p>A tabed menu with three different screens</p>
<h4 id="chirpunk"><a class="header" href="#chirpunk"><code>chirpunk</code></a></h4>
<p>A clone of the cyberpunk 2077 main menu and settings menu.</p>
<p>Demonstrates full end-to-end usage of <code>.chirp</code>, including common patterns for
managining complexity.</p>
<p>This example requires additional steps to work properly.</p>
<p>Check the <a href="../examples/./chirpunk/">example’s README</a> for more details.</p>
<h4 id="dsl_and_chirp"><a class="header" href="#dsl_and_chirp"><code>dsl_and_chirp</code></a></h4>
<p>Demonstrates the equivalence between the <code>dsl!</code> macro and the <code>.chirp</code> file
format. Also used as a test to make sure it is trully equivalent.</p>
<h4 id="sprite_debug"><a class="header" href="#sprite_debug"><code>sprite_debug</code></a></h4>
<p>Demonstrates usage of <code>cuicui_layout_bevy_sprite</code>. Due to a quirk in the way
cargo resolves workspace features, the debug overlay is specifically broken for
this. You need to use the following command line to run it with the layout debug
overlay:</p>
<pre><code class="language-sh">cargo run --bin sprite_debug -p sprite_debug --features cuicui_layout/debug
</code></pre>
<h4 id="templates-1"><a class="header" href="#templates-1"><code>templates</code></a></h4>
<p>demonstrates usage of the <code>cuicui_chirp</code> templating features. See the file in
<code>assts/templates.chirp</code> for details, as most of the interesting code is in the
chirp file itself, not the rust source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chirpunk-1"><a class="header" href="#chirpunk-1">Chirpunk</a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a></p>
<p>The cuicui cyberpunk example.</p>
<p>Inspired by <a href="https://github.com/bytestring-net/bevy-lunex"><code>bevy-lunex</code></a>’s <a href="https://github.com/IDEDARY/bevy-lunex-cyberpunk">cyberpunk example</a>.</p>
<p>This demonstrates how to create and handle a more complex menu. It has:</p>
<ul>
<li>Several screens (title screen, graphics settings, audio settings, bonus tabs)</li>
<li>Buttons with juicy hover animations</li>
<li>Nice screen effects such as background animation and bloom</li>
<li>Gamepad handling with <a href="https://lib.rs/crates/bevy-ui-navigation"><code>bevy-ui-navigation</code></a></li>
<li>Minimal data binding based on events.</li>
</ul>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Due to the nature of the assets used, I prefer not including them in this
repository. To get them, run the <code>make checkout-cyberpunk</code> make recipe.</p>
<p>The idea is to clone the bevy-lunex cyberpunk example and re-use its <code>asset</code>
directory.</p>
<p>If <code>make</code> is not an option for you, the following shell commands <em>should work</em>,
although it has only been proven to work on my machine™.</p>
<pre><code class="language-sh"># First Make sure that your working directory (PWD) is the cuicui_layout workspace root.
if not test -e CHANGELOG.md ; then
  echo &quot;your working directory (PWD) should be the cuicui_layout workspace root.&quot;
  exit 1
fi

# Create a repository for bevy-lunex-cyberpunk, without copying the files
git clone --no-checkout --depth=1 --filter=tree:0 \
    https://github.com/IDEDARY/bevy-lunex-cyberpunk.git \
    examples/chirpunk/lunex-cyberpunk-assets
# Go into bevy-lunex-cyberpunk repo and tell it to only download the 'assets' directory
cd examples/chirpunk/lunex-cyberpunk-assets
git sparse-checkout set --no-cone assets
# Check out the bevy-lunex-cyberpunk files
git checkout

# Setup the 'assets' directory in ./examples/chirpunk
cd ..
../../scripts/x_platform_ln.sh lunex-cyberpunk-assets/assets assets
cd lunex-cyberpunk-assets/assets
# add 'menus' files to the assets directory
../../../../scripts/x_platform_ln.sh ../../menus menus
cd ../../../..
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<blockquote>
<p><code>cargo run --bin chirpunk --features cuicui_layout/debug</code></p>
<p>(the feature flag is optional)</p>
</blockquote>
<p>Use <code>--no-default-features</code> to not spawn the <code>bevy-inspector-egui</code> world inspector.
And use <code>--features advanced_logging</code> to log more stuff.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Uses <code>bevy_ui</code> (through <code>cuicui_layout_bevy_ui</code>):
<ul>
<li>Bloom doesn’t work on UI</li>
<li><strong>Requires a patched version of bevy for hot reloading</strong> to work (see the
repository’s workspace <code>Cargo.toml</code>)</li>
</ul>
</li>
<li>General 3rd party crate ideas:
<ul>
<li>Extract and generalize the <code>style.rs</code> module, which is really cool.</li>
</ul>
</li>
<li>When using mouse input, the current tab in the settings menu is not highlighted.</li>
<li>The “BACK” button is part of the tabs menu</li>
</ul>
<p>The end-goal is to use <code>cuicui_layout_bevy_sprite</code> instead of
<code>cuicui_layout_bevy_ui</code> as “rendering backend”. As we don’t need <code>bevy_ui</code> for
this specific example (the only benefit of <code>bevy_ui</code> over <code>bevy_sprite</code> is
layouting, click management and borders, of which we use none), and bevy’ sprite
renderer is more flexible.</p>
<p>But I wanted to start with a working example, and <code>cuicui_layout_bevy_sprite</code>
still is missing some basic features to make it useable.</p>
<p>In the future, we will add a new bin target, that re-uses most of the code but
uses the <code>dsl!</code> macro instead of chirp files.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Since this is a complex example, it needs a bit of a “map” so that you can
orient yourself and find the landmarks that is most relevant to you.</p>
<p>We have five modules:</p>
<ul>
<li><code>dsl</code>: <strong>The most important module</strong>. A wrapper around <code>UiDsl</code> to add to the
DSL a vocabulary specific to our own UI, such as “main_menu_item” or “tab_button”.
The “method names” you see used in the <code>.chirp</code> files and <code>dsl!</code> macros are
methods on <code>BevypunkDsl</code>, and <code>UiDsl</code>, and <code>LayoutDsl</code> and <code>BaseDsl</code>.
<br />
Those are methods you can call using regular rust method syntax!</li>
<li><code>animate</code>: Animation components, used for the shift-on-hover &amp; background
police car strobe lights in the title screen</li>
<li><code>colormix</code>: defines <code>color_lerp</code> to blend bevy <code>Color</code>s in HSLuv space, used
in <code>animate</code></li>
<li><code>ui_offset</code>: Simple plugin to apply object movement AFTER <code>bevy_ui</code>’s layouting
system. Used in <code>animate</code> for the shift-on-hover effect.</li>
<li><code>style</code>: A styling module. It’s a way to change styling variable at runtime
throuhg the <code>style::Bevypunk</code> resource. This could also be loaded as a resource
or modified through <code>bevy-inspector-egui</code>.</li>
</ul>
<p>The <code>.chirp</code> files defining the menus are in the <code>menus</code> directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_dsl"><a class="header" href="#cuicui_dsl"><code>cuicui_dsl</code></a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_dsl/"><img src="https://docs.rs/cuicui_dsl/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_dsl</code> is a crate exposing a single trait (<a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/trait.DslBundle.html"><code>DslBundle</code></a>) and
a single macro (<a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a>) to define bevy scenes within rust code.</p>
<p>It is used in <code>cuicui</code> for UI, but can be used for any kind of scene.</p>
<h2 id="when-to-use-cuicui_dsl"><a class="header" href="#when-to-use-cuicui_dsl">When to use <code>cuicui_dsl</code>?</a></h2>
<ul>
<li>You want an <em>extremely lightweight</em> yet powerful scene definition DSL in bevy
to replace the innane <code>cmds.spawn(…).insert(…).with_children(…)</code> dance.</li>
<li>You don’t care about having to re-compile the whole game each time you change
your scene.</li>
</ul>
<h2 id="how-to-use-cuicui_dsl"><a class="header" href="#how-to-use-cuicui_dsl">How to use <code>cuicui_dsl</code>?</a></h2>
<ol>
<li>Define a type that implements <code>DslBundle</code></li>
<li>Define methods with a <code>&amp;mut self</code> receiver on this type</li>
<li>Use the methods of the type in question in the <code>dsl!</code> macro</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span><span class="boring">use std::borrow::Cow;
</span>use cuicui_dsl::{dsl, DslBundle, EntityCommands};

// DslBundle requires Default impl
#[derive(Default)]
pub struct MyDsl {
    style: Style,
    bg_color: Color,
    font_size: f32,
    inner: BaseDsl,
}
impl MyDsl {
    pub fn named(&amp;mut self, name: impl Into&lt;Cow&lt;'static, str&gt;&gt;) {
        self.inner.named(name);
    }
    pub fn style(&amp;mut self, style: Style) {
        self.style = style;
    }
    pub fn bg_color(&amp;mut self, bg_color: Color) {
        self.bg_color = bg_color;
    }
    pub fn font_size(&amp;mut self, font_size: f32) {
        self.font_size = font_size;
    }
}
impl DslBundle for MyDsl {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        cmds.insert(self.style.clone());
        cmds.insert(BackgroundColor(self.bg_color));
        self.inner.insert(cmds);
        // ...
        cmds.id()
    }
}
// Now you can use `MyDsl` in a `dsl!` macro
fn setup(mut cmds: Commands) {
    let height = px(32);
    dsl! {
        &lt;MyDsl&gt;
        &amp;mut cmds.spawn_empty(),
        // The uppercase name at the start of a statement is the entity name.
        Root(style(Style { flex_direction: FlexDirection::Column, ..default()}) bg_color(Color::WHITE)) {
            Menu(style(Style { height, ..default()}) bg_color(Color::RED))
            Menu(style(Style { height, ..default()}) bg_color(Color::GREEN))
            Menu(style(Style { height, ..default()}) bg_color(Color::BLUE))
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>This seems a bit verbose, that’s because you should be using <a href="https://docs.rs/crate/cuicui_layout/0.9.0"><code>cuicui_layout</code></a> and
not bevy’s native layouting algorithm (flexbox) for layouting :)</p>
<p>The <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/macro.dsl.html">docs.rs page</a> already has extensive documentation on the <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> macro,
<strong>with a lot of examples</strong>.</p>
<ul>
<li><a href="https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html">https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html</a></li>
</ul>
<p>The short of it is:</p>
<p><code>dsl!</code> accepts three arguments:</p>
<ol>
<li>(optional) the <code>DslBundle</code> type you want to use as “builder” for the DSL.</li>
<li>The <code>&amp;mut EntityCommands</code> to spawn the scene into.</li>
<li>A single statement</li>
</ol>
<p>What is a statement? A statement is:</p>
<ul>
<li>An <code>EntityName</code> (which is a single identifier) followed by either:
<ul>
<li>several methods within <code>(parenthesis)</code></li>
<li>several children statements within <code>{curly braces}</code></li>
<li>both of the above</li>
</ul>
</li>
</ul>
<p>A statement creates a <code>Default::default()</code> of the choosen <code>DslBundle</code> type.
Then, each mehtod within parenthesis is called on the choosen <code>DslBundle</code> type.
Finally, an entity is spawned using the <code>DslBundle::insert</code> method on the
thus-constructed <code>DslBundle</code>.
The spawned entity has the <code>Name</code> component set to the identifier provided for <code>EntityName</code>.</p>
<p>Children are added to that entity if child statements are specified within
braces.</p>
<p>Still confused about it? I encourage you to either look at the <a href="https://github.com/nicopap/cuicui_layout/tree/cuicui_dsl-v0.10.1/examples">examples</a>
or check the docs at:</p>
<ul>
<li><a href="https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html">https://docs.rs/cuicui_dsl/latest/cuicui_dsl/macro.dsl.html</a></li>
</ul>
<h3 id="dsl-specific-documentation"><a class="header" href="#dsl-specific-documentation">DSL-specific documentation</a></h3>
<p>Since <code>dsl!</code> is just a wrapper around method calls, you can refer to the <code>docs.rs</code>
page for the <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/trait.DslBundle.html"><code>DslBundle</code></a> implementation you chose to use in your <code>dsl!</code>.</p>
<h3 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h3>
<h4 id="behind-the-veil"><a class="header" href="#behind-the-veil">Behind the veil</a></h4>
<p>The <code>dsl!</code> macro is basically a way to translate an imperative sequential API
into a declarative functional API.</p>
<p>When you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::dsl;
<span class="boring">fn sys(mut cmds: EntityCommands) {
</span>dsl! {
    &lt;BlinkDsl&gt;
    &amp;mut cmds,
    Root {
        FastBlinker(frequency(0.5))
        SlowBlinker(amplitude(2.) frequency(3.0))
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> macro translates it into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span><span class="boring">fn sys(mut cmds: EntityCommands) {
</span>let mut root = BlinkDsl::default();
root.named(&quot;Root&quot;);
root.node(&amp;mut cmds, |cmds| {
    let mut fast_blinker = BlinkDsl::default();
    fast_blinker.named(&quot;FastBlinker&quot;);
    fast_blinker.frequency(0.5);
    fast_blinker.insert(&amp;mut cmds.spawn_empty());

    let mut slow_blinker = BlinkDsl::default();
    slow_blinker.named(&quot;SlowBlinker&quot;);
    slow_blinker.amplitude(2.);
    slow_blinker.frequency(3.0);
    slow_blinker.insert(&amp;mut cmds.spawn_empty());
});
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/trait.DslBundle.html#tymethod.insert"><code>DslBundle::insert</code></a> impl of <code>BlinkDsl</code> takes care of converting itself
into a set of components it will insert on an entity.</p>
<p>See the <a href="https://docs.rs/cuicui_dsl/0.10.1/cuicui_dsl/macro.dsl.html"><code>dsl!</code></a> documentation for more details and examples.</p>
<h4 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h4>
<p>The <code>cuicui</code> crates <em>compose</em> different <code>DslBundle</code>s with a very filthy trick.</p>
<p>Using <code>DerefMut</code>, you can get both the methods of your custom <code>DslBundle</code> and
the methods of another <code>DslBundle</code> embedded into your custom <code>DslBundle</code>
(and this works recursively).</p>
<p>Use the bevy <code>Deref</code> and <code>DerefMut</code> derive macros to accomplish this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::DslBundle;

// `= ()` means that if not specified, there is no inner DslBundle
#[derive(Default, Deref, DerefMut)]
pub struct MyDsl&lt;D = ()&gt; {
    #[deref]
    inner: D,
    style: Style,
    bg_color: Color,
    font_size: f32,
}
impl&lt;D: DslBundle&gt; DslBundle for MyDsl&lt;D&gt; {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        cmds.insert(self.style.clone());
        // ... other components to insert ...
        // Always call the inner type at the end so that insertion order follows
        // the type declaration order.
        self.inner.insert(cmds)
    }
}
// Both the methods defined on `MyDsl`
// and the provided `D` are available in the `dsl!` macro for `&lt;MyDsl&lt;D&gt;&gt;`
<span class="boring">}</span></code></pre></pre>
<h4 id="performance"><a class="header" href="#performance">Performance</a></h4>
<p>The downside of the aforementioned trick is the size of your <code>DslBundle</code>s.
Very large <code>DslBundle</code>s tend to generate a lot of machine code just to move them
in and out of functions.</p>
<p>Try keeping the size of your <code>DslBundle</code>s down using <code>bitsets</code> crates such as
<a href="https://docs.rs/enumset/latest/enumset/"><code>enumset</code></a> or <a href="https://docs.rs/bitflags/latest/bitflags/"><code>bitflags</code></a> instead of <code>bool</code> fields.</p>
<p>Consider also <code>Box</code>ing some large components such as <code>Style</code> to avoid the cost of
moving them.</p>
<h4 id="storing-a-dynamic-set-of-bundles-in-your-dslbundle"><a class="header" href="#storing-a-dynamic-set-of-bundles-in-your-dslbundle">Storing a dynamic set of bundles in your <code>DslBundle</code></a></h4>
<p>If you are a lazy butt like me, you don’t need to add a field per bundles/component
managed by your <code>DslBundle</code>, you can store a <code>Vec</code> of bundle spawners as follow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::{EntityCommands, DslBundle};

#[derive(Default)]
pub struct MyDynamicDsl(Vec&lt;Box&lt;dyn FnOnce(&amp;mut EntityCommands)&gt;&gt;);

impl MyDynamicDsl {
    pub fn named(&amp;mut self, name: &amp;str) {
        let name = name.to_string();
        self.0.push(Box::new(move |cmds| {cmds.insert(Name::new(name));}));
    }
    pub fn transform(&amp;mut self, transform: Transform) {
        self.0.push(Box::new(move |cmds| {cmds.insert(transform);}));
    }
    pub fn style(&amp;mut self, style: Style) {
        self.0.push(Box::new(move |cmds| {cmds.insert(style);}));
    }
    // ... Hopefully you get the idea ...
}
impl DslBundle for MyDynamicDsl {
    fn insert(&amp;mut self, cmds: &amp;mut EntityCommands) -&gt; Entity {
        for spawn in self.0.drain(..) {
            spawn(cmds);
        }
        cmds.id()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp"><a class="header" href="#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp">What is the relationship between <code>cuicui_dsl</code> and <code>cuicui_chirp</code>?</a></h2>
<p><code>cuicui_dsl</code> is a macro (<code>dsl!</code>), while <code>cuicui_chirp</code> is a scene file format,
parser and bevy loader. <code>cuicui_chirp</code> builds on top of <code>cuicui_dsl</code>, and has
different features than <code>cuicui_dsl</code>. Here is a feature matrix:</p>
<div class="table-wrapper"><table><thead><tr><th>features</th><th><code>cuicui_dsl</code></th><th><code>cuicui_chirp</code></th></tr></thead><tbody>
<tr><td>statements &amp; methods</td><td>✅</td><td>✅</td></tr>
<tr><td><code>code</code> blocks with in-line rust code</td><td>✅</td><td></td></tr>
<tr><td><code>code</code> calling registered functions</td><td></td><td>✅</td></tr>
<tr><td><code>fn</code> templates</td><td>rust<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td></tr>
<tr><td>import from other files</td><td>rust<sup class="footnote-reference"><a href="#2">2</a></sup></td><td></td></tr>
<tr><td>hot-reloading</td><td></td><td>✅</td></tr>
<tr><td>reflection-based methods</td><td></td><td>✅</td></tr>
<tr><td>special syntax for colors, rules</td><td></td><td>✅</td></tr>
<tr><td>lightweight</td><td>✅</td><td></td></tr>
<tr><td>Allows for non-<code>Reflect</code> components</td><td>✅</td><td></td></tr>
</tbody></table>
</div>
<p>You may use <code>cuicui_dsl</code> in combination with <code>cuicui_chirp</code>, both crates fill
different niches.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>A <code>fn</code> template is equivalent to defining a function that accepts an
<a href="https://docs.rs/bevy/0.11/bevy/ecs/system/struct.EntityCommands.html"><code>EntityCommands</code></a> and directly calls <code>dsl!</code> with it
</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cuicui_dsl::macros::__doc_helpers::*; // ignore this line pls
</span>use cuicui_dsl::{dsl, EntityCommands};

fn rust_template(cmds: &amp;mut EntityCommands, serv: &amp;AssetServer) {
  dsl! {
    cmds,
    Root(screen_root column) {
      Menu(image(&amp;serv.load(&quot;menu1.png&quot;)))
      Menu(image(&amp;serv.load(&quot;menu2.png&quot;)))
    }
  }
}
<span class="boring">}</span></code></pre></pre>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>You can — of course — import functions from other files in rust and use
that instead.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_chirp"><a class="header" href="#cuicui_chirp"><code>cuicui_chirp</code></a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_chirp/"><img src="https://docs.rs/cuicui_chirp/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_chirp</code> defines a file format for text-based bevy scene description.</p>
<p>It is used in <code>cuicui</code> for UI, but can describe any kind of scene.</p>
<p>It includes:</p>
<ul>
<li>A parser for the file format.</li>
<li>A bevy loader to load those files in bevy, with <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/loader/struct.Plugin.html"><code>loader::Plugin</code></a>.</li>
<li>A trait (<a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>) to use your own type’s methods as chirp methods</li>
<li>A macro to automatically implement this trait (<a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a>)</li>
</ul>
<p>The syntax is very close to that of <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a>’s <code>dsl!</code> macro,
with <a href="../chirp/index.html#import-statements">some additions</a>.</p>
<h2 id="when-to-use-cuicui_chirp"><a class="header" href="#when-to-use-cuicui_chirp">When to use <code>cuicui_chirp</code>?</a></h2>
<ul>
<li>You want a powerful and extensible scene definition format for bevy
to replace the innane <code>cmds.spawn(…).insert(…).with_children(…)</code> dance.</li>
<li>You want quick iteration time using hot reloading and useful error messages.</li>
<li>You want to minimize the amount of rust code you write to manage scenes.</li>
<li>You want a re-usable scene definition format.</li>
</ul>
<p>Be aware that <code>cuicui_chirp</code>, by its nature, is not a small dependency.
Consider using <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> if dependency size matters to you.</p>
<p>Also, as of <code>0.10</code>, <code>cuicui_chirp</code> doesn’t support WASM for image and font assets.</p>
<h2 id="how-to-use-cuicui_chirp"><a class="header" href="#how-to-use-cuicui_chirp">How to use <code>cuicui_chirp</code>?</a></h2>
<h3 id="cargo-features"><a class="header" href="#cargo-features">Cargo features</a></h3>
<ul>
<li><strong><code>fancy_errors</code></strong> (default): Print parsing error messages in a nicely formatted way.</li>
<li><strong><code>macros</code></strong> (default): Define and export the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a> macro</li>
<li><strong><code>load_font</code></strong> (default): load <code>Handle&lt;Font&gt;</code> as method argument</li>
<li><strong><code>load_image</code></strong> (default): load <code>Handle&lt;Image&gt;</code> as method argument</li>
<li><strong><code>more_unsafe</code></strong>: Convert some runtime checks into unsafe assumptions.
In theory, this is sound, but <code>cuicui_chirp</code> is not tested enough to my taste
for making those assumptions by default.</li>
</ul>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p><code>cuicui_chirp</code> reads files ending with the <code>.chirp</code> extension. To load a <code>.chirp</code>
file, use <code>ChirpBundle</code> as follow:</p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(feature = &quot;doc_and_test&quot;)] mod test {
</span><span class="boring">use cuicui_chirp::__doc_helpers::*; // ignore this line pls
</span>use bevy::prelude::*;
use cuicui_chirp::ChirpBundle;

fn setup(mut cmds: Commands, assets: Res&lt;AssetServer&gt;) {
    cmds.spawn((Camera2dBundle::default(), LayoutRootCamera));
    cmds.spawn(ChirpBundle::from(assets.load(&quot;my_scene.chirp&quot;)));
}
<span class="boring">}</span></code></pre>
<p>You need however to add the loader pluging (<a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/loader/struct.Plugin.html"><code>loader::Plugin</code></a>) for this to work.
The plugin is parametrized over the DSL type.
The DSL type needs to implement the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a> trait.</p>
<p>Here is an example using <code>cuicui_layout_bevy_ui</code>’s DSL:</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">#[cfg(feature = &quot;doc_and_test&quot;)] mod test {
</span><span class="boring">use cuicui_chirp::__doc_helpers::*; // ignore this line pls
</span><span class="boring">fn setup() {}
</span>use bevy::prelude::*;
use cuicui_layout_bevy_ui::UiDsl;

fn main() {
    App::new()
      .add_plugins((
        DefaultPlugins,
        cuicui_chirp::loader::Plugin::new::&lt;UiDsl&gt;(),
      ))
      .add_systems(Startup, setup)
      .run();
}
<span class="boring">}</span></code></pre>
<h3 id="dsl-specific-documentation-1"><a class="header" href="#dsl-specific-documentation-1">DSL-specific documentation</a></h3>
<p>The identifiers within parenthesis are methods on the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>.</p>
<p>Since the <code>chirp</code> format is a wrapper over a <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>, refer to the methods
on the <code>ParseDsl</code> impl you added as <code>loader::Plugin</code>.</p>
<h3 id="making-a-dslbundle-compatible-with-cuicui_chirp"><a class="header" href="#making-a-dslbundle-compatible-with-cuicui_chirp">Making a <code>DslBundle</code> compatible with <code>cuicui_chirp</code></a></h3>
<p>Let’s re-use the example in <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> and extend it to work with <code>cuicui_chirp</code>.</p>
<p>We had a <code>MyDsl</code> that implements <code>DslBundle</code>, now we need to also implement <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl/trait.ParseDsl.html"><code>ParseDsl</code></a>
for it. So that methods are accessible in <code>ParseDsl</code>, use the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/index.html"><code>parse_dsl_impl</code></a>
attribute macro, and add it to the <code>impl</code> block where all the DSL’s methods are
defined:</p>
<pre><code class="language-diff">     font_size: f32,
 }
+#[cuicui_chirp::parse_dsl_impl]
 impl MyDsl {
     pub fn style(&amp;mut self, style: Style) {
         self.style = style;
</code></pre>
<p>Yep, for the simple case that’s it. Just avoid panicking inside methods if you
want to take advantage of hot reloading.</p>
<h3 id="chirp-file-format"><a class="header" href="#chirp-file-format"><code>.chirp</code> file format</a></h3>
<p>The basic syntax is similar to the <a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a> <code>dsl!</code> macro.</p>
<p>One major difference is that <code>code</code> blocks are replaced with a function registry.
You can register a function using the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/loader/struct.WorldHandles.html"><code>WorldHandles</code></a> resource. Registered
functions are global to all chirp files loaded using <code>cuicui_chirp</code>.</p>
<p>The other differences are the addition of import statements (<code>use</code>),
template definitions (<code>fn</code>), and template calls (<code>template!()</code>).</p>
<h4 id="import-statements"><a class="header" href="#import-statements">Import statements</a></h4>
<p>They are currently not implemented, so please proceed to the next section.</p>
<details><summary><b>Draft design</b></summary>
<blockquote>
<p><strong>Note</strong>
Imports ARE NOT IMPLEMENTED</p>
</blockquote>
<p>In <code>cuicui_chirp</code> you are not limited to a single file. You can <em>import</em> other
chirp files.</p>
<p>To do so, use an import statement. Import statements <strong>are the first statements
in the file</strong>; They start with the <code>use</code> keyword, are followed by the source
path of the file to import and an optional “<code>as</code> imported_name”, this is the
name with which the import will be refered in this file.</p>
<pre><code class="language-ron">use different/file
// ...
</code></pre>
<p>You have two ways to use imports:</p>
<ol>
<li>As <strong>whole file imports</strong>. You can import any file and directly use it as
if it was a template without parameters. This is useful if you want to compose
several complex menus you write in different files.</li>
<li>As <strong>template collections</strong>. You can import individual templates defined in
a file. Just complete the path with a <code>.template_name</code>.</li>
</ol>
<p>Similarly to rust, you can combine imports, but only templates from the same file,
so the following is valid:</p>
<pre><code class="language-ron">use different/file.template
use different/file.{template1, template2}
// ...
</code></pre>
<p>Wild card imports are not supported.</p>
<h4 id="publicity"><a class="header" href="#publicity">Publicity</a></h4>
<p>However, to be able to import templates, you need to mark them as <code>pub</code> in the
source template. Just prefix the <code>fn</code> with <code>pub</code> and that’s it.</p>
</details>
<h4 id="template-definitions"><a class="header" href="#template-definitions">Template definitions</a></h4>
<p>chirp files admit a series of <code>fn</code> definitions at the very beginning of the
file. A <code>fn</code> definition looks very similar to rust function definitions.
It has a name and zero or several parameters. Their body is a single statement:</p>
<pre><code class="language-rust ignore noplayground">// file: &lt;scene.chirp&gt;
// template name
//   ↓
// vvvvvv
fn spacer() {
	Spacer(height(10px) width(10%) bg(coral))
}
//             parameter
// template name  ↓
//    ↓           ↓
// vvvvvv vvvvvvvvvvv
fn button(button_text) {
    Entity(named(button_text) width(95%) height(200px) bg(purple) row) {
        ButtonText(text(button_text) rules(0.5*, 0.5*))
    }
}</code></pre>
<p>You can call a template like you would call a rust macro, by writing the template
name followed by <code>!</code> and parenthesis:</p>
<pre><code class="language-rust ignore noplayground"><span class="boring">fn sys(cmds: &amp;mut cuicui_dsl::EntityCommands) { cuicui_dsl::dsl!(cmds,
</span>// file: &lt;scene.chirp&gt; (following)
Menu(screen_root row bg(darkgrey)) {
    TestSpacer(width(30%) height(100px) bg(pink))
    spacer!()
    button!(&quot;Hello world&quot;)
}
<span class="boring">)}</span></code></pre>
<p>When a template is called, it will be replaced by the single root statement
defined as body of the <code>fn</code> definition for that template.</p>
<h4 id="template-extras-1"><a class="header" href="#template-extras-1">Template Extras</a></h4>
<p>Template calls can be followed by <strong>template extras</strong>.</p>
<pre><code class="language-rust ignore noplayground"><span class="boring">fn sys(cmds: &amp;mut cuicui_dsl::EntityCommands) { cuicui_dsl::dsl!(cmds,
</span>// file: &lt;scene.chirp&gt; (following)
Menu(screen_root row bg(darkgrey)) {
    TestSpacer(width(30%) height(100px) bg(pink))

    // Additional method list after the template arguments list
    //       vvvvvvvvvvvvvvvvvvvvvv
    spacer!()(width(50%) bg(coral))

    // Both additional methods and additional children added after the argument list
    //                    vvvvvvvvvv
    button!(&quot;Hello world&quot;)(column) {
        MoreChildren(text(&quot;Hello&quot;))
        MoreChildren(text(&quot;World&quot;))
    }
}
<span class="boring">)}</span></code></pre>
<p>The additional methods will be added at the end of template’s root statement
method list. While the additional children statements will be added as children
of the template’s root statement.</p>
<p>Take for example this chirp file:</p>
<pre><code class="language-rust ignore noplayground">fn deep_trailing2(line, color) {
    Trailing2Parent {
        Trailing2 (text(line) bg(color) width(1*))
    }
}
fn deep_trailing1(line2, line1) {
    deep_trailing2!(line1, red) {
        Trailing1 (text(line2) bg(green) width(2*))
    }
}
deep_trailing1!(&quot;Second line&quot;, &quot;First line&quot;) (column bg(beige) rules(1.1*, 2*) margin(20)) {
    Trailing0 (text(&quot;Third line&quot;) bg(blue))
}</code></pre>
<p>It is equivalent to:</p>
<pre><code class="language-rust ignore noplayground"><span class="boring">fn sys(cmds: &amp;mut cuicui_dsl::EntityCommands) { cuicui_dsl::dsl!(cmds,
</span>Trailing2Parent(column bg(beige) rules(1.1*, 2*) margin(20)) {
    Trailing2 (text(&quot;First line&quot;) bg(red) width(1*))
    Trailing1 (text(&quot;Second line&quot;) bg(green) width(2*))
    Trailing0 (text(&quot;Third line&quot;) bg(blue))
}
<span class="boring">)}</span></code></pre>
<h4 id="parameter-substitution"><a class="header" href="#parameter-substitution">Parameter substitution</a></h4>
<blockquote>
<p><strong>Note</strong>
“argument” here may refer to two things: (1) the value passed as
argument to a template, in <code>template!(foo_bar)</code>, <code>foo_bar</code> is an argument.
(2) arguments passed to <em>methods</em>, in <code>Entity(text(method_argument))</code>,
<code>method_argument</code> is a method argument.</p>
<p>The name declared between parenthesis in the <code>fn</code> name is a <strong>parameter</strong>. In
<code>fn button(button_text)</code>, <code>button_text</code> is a template parameter.</p>
</blockquote>
<p>When a template is called, the body of the <code>fn</code> is inserted where the call
is made, arguments passed to the template are inlined within the statement
of the template body.</p>
<p>Please pay close attention to how parameters are inlined:</p>
<ul>
<li>Parameters are only inlined <strong>in method arguments</strong></li>
<li>Parameters are <strong>not inlined within quotes</strong></li>
<li>Parameters are only inlined <strong>if they are the whole argument</strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th><strong>❗ Compatibility Notice ❗</strong></th></tr></thead><tbody>
<tr><td>In the future, parameters will be allowed in more contexts: <ul><li>in method lists (such as <code>Entity(parameter)</code>)</li><li>As template names (such as <code>parameter!()</code>)</li><li>Embedded in a more complex method argument (such as <code>Entity(mehod({ width: parameter }))</code>)</li></ul></td></tr>
<tr><td>To avoid painfull breaking changes, avoid naming parameters the same as DSL methods or templates.</td></tr>
</tbody></table>
</div>
<pre><code class="language-rust ignore noplayground"><span class="boring">fn sys(cmds: &amp;mut EntityCommands) { dsl!(cmds,
</span>fn button(button_text) {
    // Will spawn an entity without name, with tooltip set to whatever
    // was passed to `button!`.
    Entity(tooltip(button_text) width(95%) height(200px) bg(purple) row) {
        // Will spawn an entity named &quot;button_text&quot; with text &quot;button_text&quot;
        button_text(text(&quot;button_text&quot;) rules(0.5*, 0.5*))

        // Current limitation:
        // `gizmo` method will be called with `GizmoBuilder(button_text)` as first
        // argument and whatever was passed to `button!` as second argument
        Gizmo(gizmo(GizmoBuilder(button_text), button_text) rules(0.5*, 0.5*))
    }
}
<span class="boring">)}</span></code></pre>
<h3 id="tips-and-tricks-1"><a class="header" href="#tips-and-tricks-1">Tips and tricks</a></h3>
<p>See the <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/index.html">dedicated documentation page</a> for all available
configuration options on <code>parse_dsl_impl</code>.</p>
<h4 id="performance-1"><a class="header" href="#performance-1">Performance</a></h4>
<p>Consider explicitly depending on the <code>log</code> and <code>tracing</code> crates, and enable the
<code>&quot;release_max_level_debug&quot;</code> features of those crates, so that log messages are
elided from release builds.</p>
<p><code>cuicui_chirp</code> contains <strong>a lot</strong> of trace logging in very hot loops.
<code>&quot;release_max_level_debug&quot;</code> will remove trace logging <strong>at compile time</strong> and
not only make the code faster (code that would otherwise read a lock atomic),
but it enables <strong>more optimization</strong>, inlining and loop unrolling.</p>
<p>First, find the version of the <code>log</code> and <code>tracing</code> crates in your dependency tree with:</p>
<pre><code class="language-sh">cargo tree -p log -p tracing
</code></pre>
<p>Then, add them to your <code>Cargo.toml</code> and enable a <code>max_level</code> feature. Note
that they are already in your dependency tree, so there is no downside to doing so:</p>
<pre><code class="language-toml">log = { version = &quot;&lt;version found with `cargo tree`&gt;&quot;, features = [&quot;release_max_level_debug&quot;] }
tracing = { version = &quot;&lt;version found with `cargo tree`&gt;&quot;, features = [&quot;release_max_level_debug&quot;] }
# Note: I recommend `release_max_level_warn` instead.
# `debug` is specific for performance regarding `cuicui_chirp`
</code></pre>
<p>Next time you compile your game, you’ll probably have to recompile the whole
dependency tree, since <code>tracing</code> and <code>log</code> are usually fairly deep.</p>
<h4 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h4>
<p>Remember the inheritance trick from <a href="https://lib.rs/crates/cuicui_dsl#inheritance"><code>cuicui_dsl</code></a>? <code>parse_dsl_impl</code> is
compatible with it. Use the <code>delegate</code> argument to specify the field to which
to delegate methods not found on the <code>MyDsl</code> impl.</p>
<pre><code class="language-rust ignore">// pub struct MyDsl&lt;D = ()&gt; {
//     #[deref]
//     inner: D,
// }
#[parse_dsl_impl(delegate = inner)]
impl&lt;D: DslBundle&gt; MyDsl&lt;D&gt; {
    // ...
}</code></pre>
<p>See <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/fn.delegate.html"><code>parse_dsl_impl::delegate</code></a>.</p>
<h4 id="reflectdsl"><a class="header" href="#reflectdsl"><code>ReflectDsl</code></a></h4>
<p>Unlike <code>cuicui_dsl</code>, it is possible to use <a href="https://docs.rs/bevy/0.11/bevy/reflect/trait.Reflect.html"><code>Reflect</code></a> to define DSLs. See the
<a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/reflect/struct.ReflectDsl.html"><code>ReflectDsl</code></a> docs for details.</p>
<h4 id="custom-parsers"><a class="header" href="#custom-parsers">Custom parsers</a></h4>
<p>Since <code>.chirp</code> files are in text format, we need to convert text into method
arguments. <code>parse_dsl_impl</code> parses differently method arguments depending on
their type.</p>
<p>See <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse_dsl_impl/fn.type_parsers.html"><code>parse_dsl_impl::type_parsers</code></a> for details.</p>
<h2 id="what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp-1"><a class="header" href="#what-is-the-relationship-between-cuicui_dsl-and-cuicui_chirp-1">What is the relationship between <code>cuicui_dsl</code> and <code>cuicui_chirp</code>?</a></h2>
<p><code>cuicui_dsl</code> is a macro (<code>dsl!</code>), while <code>cuicui_chirp</code> is a scene file format,
parser and bevy loader. <code>cuicui_chirp</code> builds on top of <code>cuicui_dsl</code>, and has
different features than <code>cuicui_dsl</code>. Here is a feature matrix:</p>
<div class="table-wrapper"><table><thead><tr><th>features</th><th><code>cuicui_dsl</code></th><th><code>cuicui_chirp</code></th></tr></thead><tbody>
<tr><td>statements &amp; methods</td><td>✅</td><td>✅</td></tr>
<tr><td><code>code</code> blocks with in-line rust code</td><td>✅</td><td></td></tr>
<tr><td><code>code</code> calling registered functions</td><td></td><td>✅</td></tr>
<tr><td><code>fn</code> templates</td><td>rust</td><td>✅</td></tr>
<tr><td>import from other files</td><td>rust</td><td></td></tr>
<tr><td>hot-reloading</td><td></td><td>✅</td></tr>
<tr><td>reflection-based methods</td><td></td><td>✅</td></tr>
<tr><td>special syntax for colors, rules</td><td></td><td>✅</td></tr>
<tr><td>lightweight</td><td>✅</td><td></td></tr>
<tr><td>Allows for non-<code>Reflect</code> components</td><td>✅</td><td></td></tr>
</tbody></table>
</div>
<p>You may use <code>cuicui_dsl</code> in combination with <code>cuicui_chirp</code>, both crates fill
different niches.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout"><a class="header" href="#cuicui_layout"><code>cuicui_layout</code></a></h1>
<p><a href="https://cuicui.nicopap.ch/introduction.html"><img src="https://img.shields.io/badge/The_Cuicui_Book-blue" alt="The Book" /></a>
<a href="https://docs.rs/cuicui_layout/"><img src="https://docs.rs/cuicui_layout/badge.svg" alt="Documentation" /></a></p>
<p><code>cuicui_layout</code> is a very primitive layouting algorithm implemented in bevy for bevy.</p>
<p>It is similar to CSS, but without the headache. The philosophy is:</p>
<blockquote>
<p><strong>You can always predict how it will look like</strong></p>
</blockquote>
<p><code>cuicui_layout</code> is fully independent from other cuicui crates, you can disable
all default feature and have a bare-bone plugin that only adds layouting components
and systems to your bevy game.</p>
<p>However, <code>cuicui_layout</code> also integrates with <code>cuicui_dsl</code> and <code>cuicui_chirp</code>.</p>
<p>See their respective documentation pages for why you’d want to use them as well.</p>
<ul>
<li><a href="https://lib.rs/crates/cuicui_dsl"><code>cuicui_dsl</code></a></li>
<li><a href="https://lib.rs/crates/cuicui_chirp"><code>cuicui_chirp</code></a></li>
</ul>
<h2 id="when-to-use-cuicui_layout"><a class="header" href="#when-to-use-cuicui_layout">When to use <code>cuicui_layout</code>?</a></h2>
<p><code>cuicui_layout</code> is always a better choice over Flexbox, the default bevy UI
layouting algorithm. I’m however not claiming that it is better than other
similar non-flexbox layouting algorithm.</p>
<p>Here is some reasons you’d prefer <code>cuicui_layout</code> over other layouting
algorithms:</p>
<ul>
<li>Friendly algo with less things to keep in your head and good defaults.</li>
<li>Uses and takes full advantage of the bevy ECS.</li>
<li>Only controls <code>LayoutRect</code>, not <code>Transform</code>, you need to add a system that sets
<code>Transform</code> based on <code>LayoutRect</code>.</li>
<li>Fully flexible and extensible, can be used with <code>bevy_ui</code>, <code>bevy_sprite</code>, your own stuff.</li>
<li>Helpful and fully detailed error messages when things are incoherent or broken.
As opposed to FlexBox, which goes “this is fine 🔥🐶🔥” and leaves you to guess
why things do not turn out as expected.</li>
<li>This is a single-pass algo, so more efficient than flexbox.</li>
<li>An extensive debugging overlay.</li>
</ul>
<h2 id="how-to-use-cuicui_layout"><a class="header" href="#how-to-use-cuicui_layout">How to use <code>cuicui_layout</code>?</a></h2>
<h3 id="cargo-features-1"><a class="header" href="#cargo-features-1">Cargo features</a></h3>
<ul>
<li><strong><code>debug</code></strong>: Enable the debug overlay</li>
<li><strong><code>reflect</code></strong> (default): Enable <code>bevy_reflect</code> impls for layout components.</li>
<li><strong><code>chirp</code></strong> (default): Enable <a href="https://lib.rs/crates/cuicui_chirp">chirp</a> <a href="https://docs.rs/cuicui_chirp/0.10.1/cuicui_chirp/parse/trait.ParseDsl.html"><code>ParseDsl</code></a> implementation for <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/dsl/struct.LayoutDsl.html"><code>LayoutDsl</code></a></li>
<li><strong><code>dsl</code></strong> (default): Define and export <code>LayoutDsl</code> <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/trait.DslBundle.html"><code>DslBundle</code></a> impl for the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/macro.dsl.html"><code>dsl!</code></a> macro</li>
</ul>
<h3 id="layouting-1"><a class="header" href="#layouting-1">Layouting</a></h3>
<p><code>cuicui_layout</code> exposes the following <a href="https://docs.rs/bevy/0.11/bevy/ecs/component/trait.Component.html"><code>Component</code></a>s to control layouting:</p>
<ul>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Node.html"><code>Node</code></a>: A layout node, either a container holding other nodes as bevy
<a href="https://docs.rs/bevy/0.11/bevy/hierarchy/struct.Children.html"><code>Children</code></a> or a leaf node.</li>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Root.html"><code>Root</code></a>: The root of a node hierarchy. You may have several, all computations
start from the root.</li>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.ScreenRoot.html"><code>ScreenRoot</code></a>: If you add this component to a <code>Root</code> entity, it will keep
the same size as the camera with the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.LayoutRootCamera.html"><code>LayoutRootCamera</code></a> component.</li>
</ul>
<p>See the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html"><code>Rule</code></a> and <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Container.html"><code>Container</code></a> documentation for detailed explanation.</p>
<p>In short: a <code>Node</code> has independent <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html"><code>Rule</code></a>s on the <code>x</code> and <code>y</code> axis. When the
node is a <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Container.html"><code>Container</code></a>, it also has additional properties that manages how
children are distributed within the container.</p>
<p>Those additional properties are:</p>
<ul>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Flow.html"><code>Flow</code></a>: The direction in which the children are distributed</li>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Alignment.html"><code>Alignment</code></a>: Where on the cross axis are nodes aligned.</li>
<li><a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Distribution.html"><code>Distribution</code></a>: How to distribute the children of this container.</li>
<li><code>margin</code>: How much margin to put on main and cross axis</li>
</ul>
<p>By default, items are aligned at the center of the container, distributed
on the flow direction evenly within the container.</p>
<p>A <code>Rule</code> tells the size of the <code>Node</code>, it can depend on the size of its children,
the size of its parent or be a fixed value.</p>
<p>There isn’t more to it, that’s pretty much all of <code>cuicui_layout</code>.
If this wasn’t clear enough please read the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html"><code>Rule</code></a> and <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Container.html"><code>Container</code></a> documentation.</p>
<h3 id="content-sized"><a class="header" href="#content-sized">Content-sized</a></h3>
<p>It is possible to size leaf nodes based on components present on the same entity.</p>
<p>Use the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/index.html"><code>content_sized</code></a> traits to do that.</p>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<p><code>cuicui_layout</code> has an integrated debugger. Enable it with the <code>cuicui_layout/debug</code>
cargo feature.</p>
<p>The debugger is an overlay displaying the extent of <code>Node</code>s and the direction
of their rules.</p>
<h2 id="why-not-flexbox"><a class="header" href="#why-not-flexbox">Why not Flexbox</a></h2>
<p>You are writing text to get 2d visual results on screen.
The translation from text to screen should be trivial, easy to do in your head.
Otherwise you need visual feedback to get what you want.
Bevy, even with hot reloading or <a href="https://docs.rs/bevy-inspector-egui/latest/bevy_inspector_egui/index.html"><code>bevy-inspector-egui</code></a>
will always have extremely slow visual feedback.</p>
<p>Flexbox has too many parameters and depends on implicit properties of UI elements,
it is not possible to emulate it in your head.</p>
<p>cuicui’s layout, in contrast to Flexbox is easy to fit in your head.
In fact, I will forecefully push cuicui’s layout algorithm in your head
in two short bullet points.</p>
<ul>
<li>A node can be a <code>Node::Container</code> and distribute its children
along a <code>Direction</code> either by evenly spacing them (<code>Distribution::FillMain</code>)
or putting them directly one after another (<code>Distribution::Start</code>).</li>
<li>A <code>Container</code>’s size can be expressed as a static value, a fraction
of the size of what contains it, or a multiple of what it contains.</li>
<li>The content of a <code>Container</code> can be <code>Alignment</code> to the start, end or center
of its parent (by default it’s centered).</li>
</ul>
<p>That’s it. There are some edge cases, but cuicui will <del>yell at you</del>
tell you nicely when you hit them and tell you how to handle them properly.</p>
<h3 id="flexbox-faq"><a class="header" href="#flexbox-faq">Flexbox FAQ</a></h3>
<p><strong>Q</strong>: Where is <code>padding</code>?
<br><strong>A</strong>: <code>padding</code> is equivalent to <code>margin</code> in cuicui_layout. <code>margin</code> and <code>border</code>
doesn’t make conceptual sense.</p>
<p><strong>Q</strong>: Why not call it <code>padding</code> then?
<br><strong>A</strong>: Look at the dictionary definition of “margin” and “padding”.</p>
<p><strong>Q</strong>: How do I center a node?
<br><strong>A</strong>: nodes are centered by default, make sure the parent’s container size
has the expected size.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_direction</code>?
<br><strong>A</strong>: use <code>row</code> and <code>column</code></p>
<p><strong>Q</strong>: What are the equivalents of <code>column-reverse</code> and <code>row-reverse</code>?
<br><strong>A</strong>: None. Use <code>Alignment::End</code> and swap your elements! Note that the <code>*-reverse</code>
flows in flexbox are very useful for internationalization. However,
when making a game, it is not enough to just swap the elements! Artistic control is
paramount and internationalization needs to be taken as a whole in the context of the UI.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_wrap</code>?
<br><strong>A</strong>: None, do you really need it?</p>
<p><strong>Q</strong>: What is the equivalent of <code>align_item</code>, <code>align_self</code>, <code>align_content</code>, <code>justify_content</code>?
<br><strong>A</strong>: After 5 years of working with CSS, I still have no clue which one does what,
and whether they really do anything, so I won’t adventure an asnwer.</p>
<p><strong>Q</strong>: What is the equivalent of <code>flex_grow</code>, <code>flex_shrink</code>, <code>flex_basis</code>, <code>gap</code>?
<br><strong>A</strong>: Do you even know what they do?</p>
<p><strong>Q</strong>: Why can’t child container overflow their parents?
<br><strong>A</strong>: It’s likely you didn’t expect this, so we report it as an error.</p>
<p><strong>Q</strong>: How do I make a grid?
<br><strong>A</strong>: <code>cuicui_layout</code> is currently not capable of managing a grid of nodes.
This might be added in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout-debug-view"><a class="header" href="#cuicui_layout-debug-view"><code>cuicui_layout</code> debug view</a></h1>
<p><code>cuicui_layout</code> has a “debug” mode. It gives a visual representation of container
and node sizes.</p>
<p><img src="https://user-images.githubusercontent.com/26321040/272255534-4cb44a1f-09c9-414e-870c-f5ebc3a468f6.jpg" alt="A screenshot of the cyberpunk menu with container outlines" /></p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ul>
<li>While the debug overlay is up, gizmos cannot be used by other plugins</li>
<li>This is only tested with <code>cuicui_layout_bevy_ui</code> and <code>cuicui_layout_bevy_sprite</code>
(I can’t implement a debug view for your personal custom UI :P)</li>
<li>The debug overlay use the bevy <a href="https://docs.rs/bevy/0.11/bevy/render/view/struct.RenderLayers.html"><code>RenderLayers</code></a> nº16 and camera order 255 to draw gizmos</li>
</ul>
<h2 id="how-to-use-the-debug-view"><a class="header" href="#how-to-use-the-debug-view">How to use the debug view?</a></h2>
<p>Enable the <code>cuicui_layout/debug</code> cargo feature.</p>
<pre><code class="language-sh">cargo run --features cuicui_layout/debug
</code></pre>
<h3 id="debug-view-mode"><a class="header" href="#debug-view-mode">Debug view mode</a></h3>
<p>There are several view modes, you cycle through them by pressing the space bar:</p>
<ul>
<li><strong>nothing</strong> (default): There is no additional informations displayed</li>
<li><strong>outlines</strong>: Displays the outline of each <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/struct.Container.html"><code>Container</code></a> and <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Node.html"><code>Node</code></a> visible
on screen, with a different color</li>
<li><strong>outlines and rules</strong>: In addition to the outline, display each node’s vertical
and horizontal <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/enum.Rule.html"><code>Rule</code></a>s.
<ul>
<li>Arrows pointing outwards left and right mean the horizontal size (width) depends on
the size of the parent of the node.</li>
<li>Arrows pointing inwards left and right mean the horizontal size (width) depends on
the size of the children of the node.</li>
<li>The absence of arrows indicate the node has a fixed size.</li>
<li>Arrows going up and down indicate the rules for the vertical size (height).</li>
</ul>
</li>
</ul>
<h3 id="debug-view-configuration"><a class="header" href="#debug-view-configuration">Debug view configuration</a></h3>
<p>The debug view can be programmatically manipulated using the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/debug/struct.Options.html"><code>Options</code></a> <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/trait.Resource.html"><code>Resource</code></a>.</p>
<h4 id="display-invisible-layouts"><a class="header" href="#display-invisible-layouts">Display invisible layouts</a></h4>
<p>The debug view does not display information about <code>Container</code>s with
a <code>ComputedVisibility</code> component returning <code>vis.is_visible() == false</code>.</p>
<p>Set the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/debug/struct.Options.html#structfield.show_hidden"><code>Options.show_hidden</code></a> field to <code>true</code> to display outlines even if the
<code>ComputedVisibility</code> is <code>false</code>.</p>
<h4 id="changeremove-the-cycling-key"><a class="header" href="#changeremove-the-cycling-key">Change/Remove the cycling key</a></h4>
<p>Maybe your game makes heavy use of the space key (I’ve heard that some plateformers use
the space key for a common action, would you belive it?) and you don’t want to cycle
through the debug views each time space is pressed.</p>
<p>You can set the <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/debug/struct.Options.html#structfield.input_map"><code>Options.input_map</code></a> value to something else:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;cuicui_layout/debug&quot;)]
fn debug_toggle(mut opts: ResMut&lt;cuicui_layout::debug::Options&gt;) {
  opts.input_map.cycle_debug_flag = KeyCode::X;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="invert-y-axis-direction"><a class="header" href="#invert-y-axis-direction">Invert Y axis direction</a></h4>
<p>Confusingly, <code>bevy_ui</code> has a downward Y axis, while <code>bevy_sprite</code> has an upward
Y axis.</p>
<p>You can configure what Y axis direction the debug overlay uses by setting the
<a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/debug/struct.Options.html#structfield.screen_space"><code>Options.screen_space</code></a> field.</p>
<p>If you are using <code>cuicui_layout_bevy_ui</code>, this should be automatically set to
<code>true</code> for you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuicui_layout-content-sized-nodes"><a class="header" href="#cuicui_layout-content-sized-nodes"><code>cuicui_layout</code> Content sized nodes</a></h1>
<p>Leaf nodes (nodes that do not contain other nodes) may be “content-sized”.</p>
<p>For example, in <code>cuicui_layout_bevy_ui</code>, a leaf node containing an image may
keep the same aspect ratio as the image.</p>
<h2 id="how-to-define-content-sized-elements"><a class="header" href="#how-to-define-content-sized-elements">How to define content-sized elements?</a></h2>
<p>First off, if you are already using <code>cuicui_layout_bevy_ui</code> or
<code>cuicui_layout_bevy_sprite</code>, <strong>you don’t need to do anything</strong>, those plugins
already take care of elements that should depend on the size of their content.</p>
<p>If you need to implement content-sized elements for your own UI stuff, you will
need to:</p>
<ol>
<li>Define a <a href="https://docs.rs/bevy/0.11/bevy/ecs/system/trait.SystemParam.html"><code>SystemParam</code></a> (we will refer to it as <code>MyContentSize</code>)</li>
<li>Implement <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/trait.ComputeContentParam.html"><code>ComputeContentParam</code></a> for <code>MyContentSize</code>
<ul>
<li>In <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/trait.ComputeContentParam.html#associatedtype.Components"><code>ComputeContentParam::Components</code></a>, tell which components are used to
tell content size. Use <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/struct.AnyOf.html"><code>AnyOf</code></a> if several.</li>
<li>In <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/trait.ComputeContentParam.html#tymethod.condition"><code>ComputeContentParam::condition</code></a>, tell when the size update system should run</li>
</ul>
</li>
<li>Implement <code>ComputeContentSize</code> for <code>MyContentSize</code>. <a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/trait.ComputeContentSize.html#tymethod.compute_content"><code>ComputeContentSize::compute_content</code></a>
is ran for each leaf node <a href="https://docs.rs/bevy/0.11/bevy/ecs/prelude/struct.Entity.html"><code>Entity</code></a> with the provided components.
<ul>
<li>The sizes infered by the layouting algorithm is passed as the <code>set_size</code>
parameter.</li>
<li>The return value is the sizes as they should be, based on the passed <code>components</code></li>
<li>Note that the non-content-sized axis will always keep the pre-set size, regardless
of the return value.</li>
</ul>
</li>
<li>Register <code>MyContentSize</code> as a content sized element computation using
<a href="https://docs.rs/cuicui_layout/0.10.1/cuicui_layout/content_sized/trait.AppContentSizeExt.html#tymethod.add_content_sized"><code>app.add_content_sized::&lt;MyContentSize&gt;()</code></a>.</li>
</ol>
<p>And that’s it!</p>
<p>The two distinct traits are required due to a limitation in the rust type system.
Trying to merge the two traits came close to unleashing Cthulhu into the world.
Do not ask me to merge them, do not open an issue for merging them, this way
lies madness.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The best examples are the <code>content_sized.rs</code> modules in <code>cuicui_layout_bevy_ui</code>
and <code>cuicui_layout_bevy_sprite</code>.</p>
<p>Please take a look at them to get an idea of the kind of code you need to write.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
